### 垃圾回收与算法
#### 一、如何确定垃圾
- 引用计数：
  - 一个对象如果没有任何与之关联的引用，即他们的引用计数都不为0，则说明对象不太可能再被用到，那么这个对象就是可回收对象
  - 引用计数可能会出现循环引用的问题，导致一部分内存永远无法回收
  
- 可达性分析：
  - 通过一系列的GC roots对象作为起点进行搜索，如果GC roots与对象之间没有一个可达路径，则这个对象就是不可达的
  - 不可达的对象需要经过两次标记才会最终被GC回收

- 标记清除算法Mark Sweep  --- 碎片化问题严重
    - 最基础的垃圾回收算法，分为两个阶段，标注和清除。标记阶段标记出所有需要回收的对象，清除阶段回收被标记的对象所占用的空间

- 复制算法 copying --- 内存会需要翻倍，对象多也很耗时

- 标记整理算法 - Mark Compact
    - 标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象

- 分带收集算法 --- 新生代和老年代分代回收
- 新生代的复制算法：新生代对象的更迭很快，很快就会被回收，因而被整理的对象会比较少，内存和时间的小号就会比较少
```text
对象的内存分配主要在新生代的Eden Space和Survivor Space的From Space(Survivor目前存放对象的那一块)，少数情况会直接分配到老生代。 

当新生代的Eden Space和From Space空间不足时就会发生一次GC

进行GC后，Eden Space和From Space区的存活对象会被挪到To Space，然后将Eden Space和From Space进行清理

如果To Space无法足够存储某个对象，则将这个对象存储到老生代。
 
在进行GC后，使用的便是Eden Space和To Space了，如此反复循环

当对象在Survivor区躲过一次GC后，其年龄就会+1。默认情况下年龄到达15的对象会被移到老生代中。
```
- 老年代的标记整理算法：老年代因为很少进行更迭，并且内存占用相对较大，因而通过简单的二次标记并整理即可

- 以上是一些垃圾回收算法，下面会介绍使用他们的垃圾回收器，真正作用在垃圾回收部分
- 串行算法

- 并行算法
- CMS算法
- G1算法
- ZGC算法


### java中的引用类型
- 强引用 -- new String()

- 软引用 -- SoftReference,系统内存不足够时会将其回收

- 弱引用 -- WeakReference,下一次GC来就会将其回收

- 虚引用 --PhantomReference,不能单独使用，必须和引用队列联合使用，主要用于跟踪对象被垃圾回收的状态

### 分代回收算法
#### 新生代 -- 复制算法
#### 老年代 -- 标记整理算法
#### 分区回收算法-- 不分老年代和新生代的区别，将内存分区进行回收

### GC垃圾回收器
```text
新生代收集器：Serial,ParNew ,Parallel scavenge

老年代收集器：CMS,Serial Old,Parallel Old

分区收集器： G1

```
//-------------------新生代--------------------------//
#### Serial串行回收器 -- 利用单线程复制算法 -- jdk1.3 -- 暂停所有用户线程
```text
Serial是一个单线程的收集器

它不但只会使用一个CPU或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束

Serial垃圾收集器虽然在收集垃圾过程中需要暂停所有其他的工作线程

但是它简单高效，对于限定单个CPU环境来说，没有线程交互的开销，可以获得最高的单线程垃圾收集效率

```
- Serial垃圾收集器依然是java虚拟机运行在Client模式下默认的新生代垃圾收集器


#### ParNew 多线程串行收集器 -- 多线程复制算法 -- 暂停所有用户线程
- ParNew垃圾收集器其实是Serial收集器的多线程版本，也使用复制算法
- 除了使用多线程进行垃圾收集之外，其余的行为和Serial收集器完全一样，ParNew垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程
- ParNew收集器默认开启和CPU数目相同的线程数，可以通过-XX:ParallelGCThreads参数来限制垃圾收集器的线程数
- ParNew垃圾收集器是很多java虚拟机运行在Server模式下新生代的默认垃圾收集器

#### Parallel scavenge -- 多线程复制算法 高效  -- 暂停所有用户线程
- 同样是多线程复制算法，但是它能达到一个可控制的吞吐量
- 自适应调节策略也是ParallelScavenge收集器与ParNew收集器的一个重要区别

//-------------------老年代---------------------//
#### Serial Old -- 单线程标记整理算法  -- 暂停所有用户线程
- 运行在Client默认的java虚拟机默认的年老代垃圾收集器
- jdk1.5之前Parallel scavenge +Serial Old
- 是CMS的后备方案

#### Parallel Old -- 多线程标记整理算法-- jdk1.6之后 -- 为了弥补Serial Old的吞吐量不足 -- 暂停所有用户线程

#### CMS - ConcMarkSweep -- 多线程标记清除算法 -- 获取最短的停顿时间
- 标记阶段 ：只是标记一下GC Roots能直接关联的对象，速度很快，仍然需要暂停所有的工作线程
- 并发阶段： 进行GC Roots跟踪的过程，和用户线程一起工作，不需要暂停工作线
- 重新标记：为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程
- 并发清除：清除GC Roots不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS收集器的内存回收和用户线程是一起并发地执行

#### G1 -- 分区收集器 --整体基于标记整理算法的分region回收
- 由于CMS采用的标记清楚会产生很多内存碎片，不利于内存空间的使用，并且在标记阶段仍会造成用户线程停顿，因而出现了G1
- 它采用将内存划分为大小固定的几个区域Region概念，跟踪区域的垃圾收集进度，维护一个优先级列表，根据允许的收集时间，优先回收垃圾最多的区域
- 每个 Region 都有一个 Remembered Set，用来记录该 Region 对象的引用对象所在的 Region。通过使用 Remembered Set，在做可达性分析的时候就可以避免全堆扫描
- 流程：
```text
1.初始标记

2.并发标记

3.最终标记
为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行

4.筛选回收
首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划

```
- 区域划分和优先级区域回收机制，确保G1收集器可以在有限时间获得最高的垃圾收集效率
- 它能够实现无内存碎片，精准控制停顿时间，停顿时间可预测

### MinorGC和FullGC
- MinorGC:在前面的描述中，我们看到了MinorGC会产生在新生代中，并且会频繁的调用，不过调用耗时很短
- Eden满了就会触发MinorGC

- FullGC:是在全部堆内存不足的情况下触发的，针对新生代和老年代，覆盖范围大，耗时长
- FullGC可能出发的情况
```text
1. System.gc()

2.老年代空间不足

3.空间分配担保失败

4.jdk1.7之前，永久代空间不足

5.CMS中老年代空间不足：
执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC


```


