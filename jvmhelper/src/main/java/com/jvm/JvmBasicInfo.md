### 一、基础概念
#### JVM JDK JRE
  JVM > JDK > JRE

#### JVM特点：语言无关性和平台无关性
  - 一个类， 通过各种对应的编译器编译后，都可以生成字节码文件.class
  - 字节码文件都可以通过java命令进行运行，运行在JVM环境中
  - JVM环境能够稳定运行在Windows\Unxi\others等多种操作系统之上
  - 结合以上能够了解jvm的两个特点
```text
   (*.java)          (*.rb)         (*.groovy)          (...)
       |                |               |                 |
   (javac编译器)    (jrubyc编译器)  (groovyc编译器)    (其他编译器)
       |                |               |                 |
       ----------------------------------------------------
                                |
                         (.class字节码文件)
                                |
                     (JVM---classloader类加载)
                                |
                  ------------------------------
                  |             |              |解释为本地机器指令
               (Windows)      (Unix)        (Other)
```
#### JVM 运行时数据区：
其中堆和方法区是共享数据区，程序计数器、虚拟机栈、本地方法栈是线程隔离的数据区
- 虚拟机栈：存储当前线程运行方法所需要的数据，指令，返回地址
  - 在基础java学习中有提到，局部变量表，操作数栈动态链接，出口，函数调用流程，方法调用链都会存储在栈当中
  - 关于局部临时变量，直接存储值，关于引用变量，存储堆的地址引用
  - 关于StackOverFlow就是栈溢出，无法存储更多临时操作
  - 栈的大小可以通过JVM参数进行配置：-Xss设置每个线程的堆栈大小，比如-Xss256k
  - 操作数栈其实就是记录了函数调用的流程，可以将class文件输出到txt，可以查看到
  - 本地方法栈：为虚拟机使用到的Native方法服务
  - 堆：Java堆是所有线程共享的一块内存区域，存放实例对象
  - 方法区：用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据
  - 程序计数器：当前线程多执行字节码的行号指示器，上下文切换的各种指令状态的维护都交给它

- 两数相加class指令:
```
public int getSum(int, int);
  descriptor: (II)I
  flags: ACC_PUBLIC
  Code:
    stack=2, locals=3, args_size=3
       0: iload_1  //局部变量1压栈
       1: iload_2  //局部变量2压栈
       2: iadd  //两数相加
       3: ireturn  //结果返回
    LineNumberTable:
      line 12: 0
```

   
### 二、从一个类的执行看JVM
#### 1.准备工作
- 首先编写一个简单的类Person 
- 通过javac将.java文件编译成.class文件
- 通过java命令运行.class文件

#### 2.编译流程
- 源代码 --> 词法分析器 --> token流 --> 语法分析器 -->  语法树/抽象语法树 -->  语义分析器 --> 注释抽象语法树 --> 字节码生成器 --> JVM字节码
- 以上流程可以理解为三个过程： 分析和输入到符号表  --> 注解处理 --> 语义分析和生成class文件
-  语法糖的含义：编译器实现的一些小把戏，可以使效率大大提升，比如泛型（无需墙砖，运行没有警告，只做类型限定）
- jdk的作用： 区分操作系统，使java编译的操作指令能与本地系统兼容（这也是java平台无关性、跨平台的一个原因）
- 泛型擦除，在编写java代码的时候会用到泛型T/?之类的，可以做参数的适配或者限制，但是在编译时期，对应的泛型就会被转化为原生类型（Raw Type，称为裸类型），这个过程叫做泛型擦除
- 类的加载时交给JVM动态加载的，但是也有5种情况下，会`立即`对类进行初始化（class文件加载如JVM容器中）
    - new 的方式创建类的实例，静态相关（访问某个类的静态变量，对某个类的静态变量赋值，调用类的静态方法）
    - 反射的方式，显示地通过Class.forName(...)创建类对象
    - 继承的时候，要初始化子类对象，必须要先初始化一个父类的对象
    - 启动类，在java运行的时候外部显示指定的主类
    - 当使用JDK1.7的动态语言支持时（这个不是很了解）
- 类的动态加载，可以很好的利用内存开销

#### 3.将类（class）加载入JVM
- 类加载器有：
    - 启动类加载器（Bootstrap Classloader）: 加载java_home jre/lib/rt.jar,用来保障java环境，由C++实现
    - 扩展类加载器（Extension ClassLoader）: 负责加载扩展类，java_home jre/lib/ext或者显示指定的-Djava.ext.dirs指定目录下的jar包  
    - 应用类加载器（AppClassLoader）: 加载应用下Classpath下的jar包中的class
    - 自定义类加载器（User ClassLoader）:
- 工作过程：
    - 双亲委派模型：拿到类加载任务，先向上委派给父加载器执行，如果无法加载，再把任务下放
        - 当AppClassLoader需要加载一个类的时候，它需要将类加载的请求委派给它的父加载器ExtClassLoader执行；
        - ExtClassLoader接受到执行任务，需要继续将这个加载任务请求它的父加载器BootStrapClassLoader去执行；
        - 如果BootStrapClassLoader加载成功，即将目标类加载入JVM ，如果加载失败，继续将加载任务下放给ExtClassLoader;
        - 如果ExtClassLoader加载成功，即将目标类加载入JVM，如果加载失败，继续将加载任务下放给AppClassLoader；
        - 如果AppClassLoader加载成功，即将目标类加载入JVM，如果加载失败，抛出异常ClassNotFoundException.
    - 好处：避免整个JVM容器当中出现多份同样的字节码
    - 说明: 当一个类被加载成功，会将对应的实例缓存起来，下次在请求类加载的时候，无需尝试再次加载
    
- 类加载的详细过程
    - 流程图：
    ![avator](https://raw.githubusercontent.com/CzyerChen/recording/master/img/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)
    - 类的生命周期有7个流程：
      1. 加载（Loading）：查找并加载类的二进制数据，在java队中创建一个Class类对象
      2. 验证（Verification）：文件格式、元数据、字节码、符号引用验证
      3. 准备（Preparation）：为类的静态变量分配内存，将其初始化为默认值
      4. 解析（Resolution）：将类中的符号引用转为直接引用
      5. 初始化（Initialization）： 为类的静态变量赋予正确的初始值
      6. 使用（Using）
      7. 卸载（Unloading） 
    - 连接包含验证(b),准备(c)，初始化(d)

#### 4.JIT即时编译器
- 对于加载的Class文件，对于热点代码（重要代码，重复调用的代码，循环的代码），会将class字节码重新编译优化，转化为机器码，直接让CPU执行，对于非热点代码，直接解析
- 热点代码可以使用热点探测来检测是否为热点代码：采样/计数器，两种方式
- 目前热点探测使用的是计数器方式，检测时需要为每个方法准备`方法调用计数器`,`回边计数器`
- 以上两个计数器有阈值，当计数器超出阈值时，就会触发JIT编译


### 三、JVM内存结构/内存分区/内存模型
- JVM内存模型的变化
```text
jdk 1.8及以后    |---------------------------------------------------------|            |------------|
                |                新生代                          老年代     |            |   元空间    |
                |   |-----------| |---------| |--------|    |-----------|  |            |            |
                |   |           | |         | |        |    |           |  |            |            |
                |   |           | |         | |        |    |           |  |            |            |     
                |   |  eden     | |   S0    | |  S1    |    |           |  |            |            |
                |   |           | |         | |        |    |           |  |            |            |
                |   |           | |         | |        |    |           |  |            |            |
                |   |-----------| |---------| |--------|    |-----------|  |            |            |
                |----------------------------------------------------------|            |------------|


jdk1.7及之前  |---------------------------------------------------------------------------|
             |                新生代                          老年代          永久代       |
             |   |-----------| |---------| |--------|    |-----------|  |------------|   |
             |   |           | |         | |        |    |           |  |            |   |
             |   |           | |         | |        |    |           |  |            |   |     
             |   |  eden     | |   S0    | |  S1    |    |           |  |            |   |
             |   |           | |         | |        |    |           |  |            |   |
             |   |           | |         | |        |    |           |  |            |   |
             |   |-----------| |---------| |--------|    |-----------|  |------------|   |
             |---------------------------------------------------------------------------|


```
- 中间有一个非常重要的就是永久代取消，对一些需要长期保持在JVM环境中的数据存放到堆上，因而JVM的内存利用有了一定的提高，不会在被永久代羁绊了。取而代之的元空间是物理内存
- 新生代的区域又分为eden区，s0区，s1区，默认比例是8:1:1



    





