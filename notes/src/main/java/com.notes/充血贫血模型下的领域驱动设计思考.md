- 领域设计比较涉及概念性，需要顶层设计的需要好好熟悉这些概念，而需要普通编码的也需要有一个大致的了解
- 面对混乱的代码，面对需求的无限变更，基于面向对象思想的领域驱动设计方法是一个很好的解决方法
- 系统设计的顶层建筑是对整个软件有极大影响的
- 本文向系统设计师取经，参考[互联网文章1](http://www.blogjava.net/johnnylzb/archive/2010/05/15/321057.html)，[2](https://kb.cnblogs.com/page/520746/)
- 借鉴引文例子，看需求变更下的系统设计：
```text
假设现在有一个银行支付系统项目，其中的一个重要的业务用例是账户转账业务。系统使用迭代的方式进行开发，在1.0版本中，该用例的功能需求非常简单，事件流描述如下：

主事件流：

1）  用户登录银行的在线支付系统

2）  选择用户在该银行注册的网上银行账户

3）  选择需要转账的目标账户，输入转账金额，申请转账

4）  银行系统检查转出账户的金额是否足够

5）  从转出账户中扣除转出金额（debit），更新转出账户的余额

6）  把转出金额加入到转入账户中（credit），更新转入账户的余额

备选事件流：

4a）如果转出账户中的余额不足，转账失败，返回错误信息
```
- 以下类规范设计请参考`类命名规范``

### 1. 面向过程的设计及方式（贫血模式）
- 以上需求的大体设计
```text
1）设计一个账户交易服务接口AccountingService，设计一个服务方法transfer()，并提供一个具体实现类AccountingServiceImpl，所有账户交易业务的业务逻辑都置于该服务类中。
2）提供一个AccountInfo和一个Account，前者是一个用于与展示层交换账户数据的账户数据传输对象，后者是一个账户实体（相当于一个EntityBean），这两个对象都是普通的JavaBean，具有相关属性和简单的get/set方法。

```

记录几次需求的变更：
- 需求变更1：需要为账户转账业务增加如下功能，在转账时，首先需要判断账户是否可用，然后，账户的余额还要分成两部分：冻结部分和活跃部分，处于冻结部分的金额不能用于任何交易业务
- 需求变更2：需要在每次交易成功后，创建一个交易明细账，于是，我们又必须在transfer()方面里面增加创建并持久化交易明细账的业务逻辑
- 需求变更3：账户每笔转账的最大额度需要由其信用指数确定、需要根据银行的手续费策略计算并扣除一定的手续费用


- 以上方法会使整体的转帐业务流程变得非常臃肿，包含太多需要考虑的部分，即使拆分子功能，在后期扩展调用的时候仍会出现很多问题
- 这个时候就需要将业务长久考虑，将支付相关的操作抽离转帐的主逻辑，将它们抽象为公共服务，实现基于领域驱动设计的理念

### 2.面向过程的领域驱动设计方式（充血模型）
- 领域模型：用户账号，账户交易明细，账户信用等级，银行交易手续费计算器
- 判断余额是否足够、判断账户是否可用、改变账户余额、计算手续费、判断交易额度、产生交易明细账
- 经过这样的设计，前例中所有放置在服务对象的业务逻辑被分别划入不同的负责相关职责的领域对象当中，下面的时序图描述了AccountingServiceImpl的转账业务的实现逻辑（为了简化逻辑，我们忽略掉事物、持久化等逻辑）


- 面向领域设计优点：
    - 业务逻辑被合理的分散到不同的领域对象中，代码结构更加清晰，可读性，可维护性更高。
    - 对象职责更加单一，内聚度更高。
    - 复杂的业务模型可以通过领域建模（UML是一种主要方式）清晰的表达，开发人员甚至可以在不读源码的情况下就能了解业务和系统结构，这有利于对现存的系统进行维护和迭代开发。
    - 系统高度模块化，代码重用度高，不会出现太多的重复逻辑
   

### DDD中的失血、贫血、充血、胀血模式
- 失血模型：
模型仅仅包含数据的定义和getter/setter方法，业务逻辑和应用逻辑都放到服务层中。这种类在Java中叫POJO，在.NET中叫POCO，领域层啥都不干

- 贫血模型：
贫血模型中包含了一些业务逻辑，但不包含依赖持久层的业务逻辑。这部分依赖于持久层的业务逻辑将会放到服务层中，对象和持久层没有直接联系

- 充血模型：
充血模型中包含了所有的业务逻辑，包括依赖于持久层的业务逻辑（save update ....)， UI层->服务层->领域层<->持久层

- 胀血模型：
胀血模型就是把和业务逻辑不想关的其他应用逻辑（如授权、事务等）都放到领域模型中,领域层啥都干了
  
- 以上四种架构模式，什么都做和什么都不做肯定是不行的，那具体的持久层的职责是交给领域和是服务呢？这就是充血和贫血的选择

### 充血模型和贫血模型的对比
- 以上例子没有说明情况，原文会细致一些，后来看到了知乎上的一些讨论
- 贫血模式指，只有getter setter方法的对象，我们很多开发都是这样，利用Spring一些架构根深蒂固的影响，我们定义实体，通过service或者DAO这种类来操作对象，对象蜕化成为一个简单的数据结构，一个对象实体没有能力只是呈现了自己的属性
- 充血模式指，一个对象，既然不是简单的属性，那就可以承载一些基础的动作，比如User 有行走的能力，有睡觉的能力，有吃饭的能力，比如有一个方法action(),就可以返回这个对象接下去的操作，user.action(),但是显然，我们目前的一些coding中不可能会这么做
- 看到大家讨论，标识充血模式是面向对象这个概念很好地一个实践，但是是否真的完全应该选择充血模式，这倒没有看到一个说法
- 贫血模式中会把数据操作封装多层：service -> DAO ,而充血模式只是简单的一层就可以搞定
- 层次如果封装的没有那么过度，或许也问题不大，但是充血模式中大多业务逻辑和持久化放在Domain Object里面，而不是service或者DAO层
- 看到一些讨论：
1. 贫血模型里没有实现方法，那它的增删改查是在哪实现的
贫血模式需要DAO专门做数据库操作

2. 贫血模型有什么缺点
业务逻辑都放在service层，显得太过沉重

3. 典型的WEB应用中使用贫血模型，还是充血模型？为什么
Web会使用贫血模式，典型的web应用中，简单的CRUD操作占据了业务逻辑的绝大多数比例，可以避免了业务逻辑不得不大量封装DAO接口的问题，简化了软件架构设计，节省了大量的业务层代码量
原因：
（1）基于组建技术，全部应用对象都是java组件，Spring这种框架提供的完备的对象生命周期管理
（2）不依赖于servlet API
（3）可以任意使用各种视图技术,而不仅仅局限于JSP
（4）支持各种请求资源的映射策略
（5）易于扩展

- 贫血模式模式的优缺点：
优点
```text
优点是系统的层次结构清楚
各层之间单向依赖，Client-＞(Business Facade)-＞Business Logic-＞Data Access(ADO.NET)
当然Business Logic是依赖Domain Object的，Spring : service->DAO -> entity
```
缺点
```text
该模型的缺点是不够面向对象
领域对象只是作为保存状态或者传递状态使用
所以就说只有数据没有行为的对象不是真正的对象
在Business Logic里面处理所有的业务逻辑，在POEAA(企业应用架构模式)一书中被称为Transaction Script模式
```
- 充血模式的优缺点
优点
```text
大多业务逻辑和持久化放在Domain Object里面，Business Logic只是简单封装部分业务逻辑以及控制事务、权限等，
这样层次结构就变成Client-＞（Business Facade)-＞Business Logic-＞Domain Object-＞Data Access。

它的优点是面向对象，Business Logic符合单一职责，不像在贫血模型里面 那样包含所有的业务逻辑太过沉重。
```
缺点：
```text
缺点是如何划分业务逻辑，
什么样的逻辑应该放在Domain Object中，
什么样的业务逻辑应该放在Business Logic中，这是很含糊的。
即使划分好了业务逻辑，由于分散在Business Logic和Domain Object层中，不能更好的分模块开发。
熟悉业务逻辑的开发人员需要渗透到Domain Logic中去，而在Domian Logic又包含了持久化，对于开发者来说这十分混乱。
其次，因为Business Logic要控制事务并且为上层提供一个统一的服务调用入口点，它就必须把在Domain Logic里实现的业务逻辑全部重新包装一遍，完全属于重复劳动

```


### 是否充血模式就是遥不可及？
- 上面的总结或许看起来告诉你，算了吧，业务上还是用贫血模型吧，充血模型当理论看看就行了，不是高级人就不要自己绕自己，和自己过不去了，但是进一步看看Spring  Hibernate 和JPA
- 又看到了MDA DDD 顺路看一下定义
```text
MDA Model Driven Architecture -- 模型驱动架构 属于架构方法
希望一个很高程度的原型设计，比如一个销售逻辑的原型设计，你可以应用于教育，又可以应用于工业化，
一劳永逸的操作，可以做很大的适配，但是实际上很难落地，往往实现和原型会有很大差异

EDA 事件驱动架构

DDD Domain Driven Design -- 领域驱动设计 属于设计方法
关注点在于领域对象，中间的领域层很重要，与展示层和数据存储层隔离开来，注重业务逻辑
 
MDD  Model-Driven Development 探索模型驱动开发，开发方法

MDA -> DDD -> MDD

```

- 去下一篇看看Spring JPA中的DDD