- 内存泄漏是一个容易被忽视、一旦出问题就不太好解决的问题，关乎JVM的内存、关乎应用的存亡。
- JVM内存一个很好的朋友就是垃圾回收机制，它主要负责在应用生命周期以内，对内存数据碎片没有引用的部分，定期对它们进行回收再分配
- 但是当一些应用操作的失误、数据细节的忽视、资源未关闭等情况，会耗尽内存、降低系统性能，带来恶劣的结果。如果不处理，应用程序最终将耗尽其资源，最终以致命的java.lang.OutOfMemoryError终止。
                                                     
### 一、内存泄露的定义
内存泄漏是堆中存在不再使用的对象但垃圾收集器无法从内存中删除它们的情况

### 二、内存泄漏的症状
1. 应用程序长时间连续运行时性能严重下降
2. 应用程序中的OutOfMemoryError堆错误
3. 自发且奇怪的应用程序崩溃
4. 应用程序偶尔会耗尽连接对象

### 三、内存泄漏的类型
关于程序操作中，以下是可能使用到、又极易被忽略的情况，希望引起关注，做完美的coding.

1.Static字段
Static的类型会在程序初始化之后一直在内存中，直到程序终止，拥有与整个应用程序相匹配的生命周期，因而静态资源的定义需要谨慎；

- 预防：最大限度减少静态变量的使用；使用单例时，也避免使用立即加载的方式，而采用延时加载、用时加载；

2.未关闭的资源
包括数据库连接池、网络请求、读写文件、会话对象
- 预防：始终使用finally进行资源的关闭和回收、关闭资源的代码中不应该有异常或者继续捕获；了解一下try+with+resource;

3.不正确的equals和hashcode
特别是在自定义对象比较的时候，必须实现以上两个方法，不然程序将进入默认比较方法，耗费不必要的内存，类似与HashMap\HashSet，都会默认对key进行排重处理，觉得没有需要比较的地方但是却存在；

- 预防：在自定义实体的时候，都建议把equals hashcode方法写上；并且对于需要频繁比较的，更应该优化比较的方法；

4.引用了外部类的内部类
出于一些设计层面的问题，用到了外部类、内部类这样的设计，但是在使用中在不用外部类的时候，强行需要显示的new一个内部类，那么在使用内部类的时候其实会默认实例化一个外部类（这一个部分可以去看一下内部类的字节码，了解编译的时候内部类是如何实现访问的），并且这个实例的引用是隐式的；

- 预防：这种内部类的使用与他的设计方案是有冲突的，建议重新设计；

5.Finalize
这个方法是手动通过方法，将某个或某些对象进行垃圾回收，但是这个方法其实是将这个对象标记为可回收，去掉了它的所有引用，是否回收、何时回收都是依靠JVM自身的排队算法确定，因而会给人一种调用即回收了的错觉；
- 预防：避免使用finalize

6.字符串常量
字符串常量从永生代（PermGen）转换到堆空间，jdk7之前的字符串常量也是伴随程序的生命周期的，jdk7+就在堆上了；
- 预防：升级JDK版本；在使用长字符串的时候，加大永生代的大小；（-XX：MaxPermSize=512m）

7.ThreadLocal
本地Entry数组对ThreadLocal变量副本有一个弱引用，当当前线程不再存在，当前线程对Key的引用就会消失，可是ThreadLocal的弱引用还存在，因而无法被回收。
- 预防：手动调用remove方法，可以循环检验ThreadLocal的引用，并将其指向null；不要使用set(null)的方式来清除引用，因为无效；

### 四、内存检测工具
JProfiler
Profiling
Java VisualJVM

### 五、[JVM OOM的几种情况,转自](https://mp.weixin.qq.com/s?__biz=MzUxOTc4NjEyMw==&mid=2247484134&idx=1&sn=d48e0792697fc25013459404988e06af&chksm=f9f51902ce8290142ca9735d3591b21385154c7022de419bcea17693bfee2712fa6fdfc2f056&token=1379535535&lang=zh_CN&key=59679eecdce1d5f03c364916b2274dfbf16d08c9be54a8aacf237516a16a31cc499176d0e750cab773462961b7e98cb6a0d9138593a62bc6523ae84ea3b2a0e56cac33414250ae88696c9ee177391e10&ascene=1&uin=MTA4NjE2NTIyNA%3D%3D&devicetype=Windows+10&version=62060739&pass_ticket=KFYhA4IsoAmmNZ30lWG2b%2Bj3xJa7rkXfI6Qn2rgostn04tzq4cf6feFY0zSiJXPI)
#### 发生在堆上
- 很多内存泄露的情况都可能是发生在对上，数据对象的内存没有及时回收，新生代或者老年代或者永久代的内存耗尽，就会产生OOM
- 原因就是以下几点：
```text
1.无法在堆上分配对象

2.吞吐量增加

3.应用程序无意中保存了对象引用，对象无法被 GC 回收

4.过度使用 finalizer。finalizer 对象不能被 GC 立刻回收，上面也有介绍，只是标记，最终回收还是看GC

```
- 解决方案？扩大堆，或者找出操作隐患？
```text
使用 -Xmx 增加堆大小

修复应用程序中的内存泄漏

```
#### GC的开销太大
- 有一些情况，堆上对象过多，GC回收很缓慢，造成应用卡顿，甚至OOM
- 解决方案;
```text
1.使用 -Xmx 增加堆大小

2.使用 -XX:-UseGCOverheadLimit 取消 GC 开销限制

3.修复应用程序中的内存泄漏
```
#### 建立过多线程池，资源耗尽
- 内存不足，无法创建新线程
- 解决方法：
```text
1.为机器分配更多的内存

2.减少 Java 堆空间

3.修复应用程序中的线程泄漏

4.增加操作系统级别的限制
- ulimit -a 用户进程数增大 (-u) 1800  使用 -Xss 减小线程堆栈大小
```

#### 数组长度越界
- 这类问题就是一般对问题预估不当或者开发当中可能出现的问题，一般线上出现的可能性会相对较小
- 解决方案：
```text
1.使用 -Xmx 增加堆大小

2.修复应用程序中分配巨大数组的 bug
```
#### Perm gen 空间耗尽
- 类的名字、字段、方法,与类相关的对象数组和类型数组,JIT 编译器优化所共占用的资源耗尽，将OOM
- 解决办法:
```text
1.使用 -XX: MaxPermSize 增加 Permgen 大小

2.不重启应用部署应用程序可能会导致此问题。重启 JVM 解决
```

### 元数据区耗尽
- 同上一个一样的问题，由于JDK8开始类的名字、字段、方法,与类相关的对象数组和类型数组等资源的存储放在了本地的元数据区，因而这些资源的过大，会导致元数据区耗尽
- 解决办法：
```text
1.通过命令行设置 -XX: MaxMetaSpaceSize 增加 metaspace 大小

2.取消 -XX: maxmetsspacedize

3.减小 Java 堆大小,为 MetaSpace 提供更多的可用空间

4.为服务器分配更多的内存

5.可能是应用程序 bug，修复 bug
```

#### 杀死进程或子进程
#### 发生 stack_trace_with_native_method