- 看过了定时任务的执行，很重要的就是通过一个线程池去组织一堆定时任务

### 计划线程池
```text
                         ExecutorService接口
                              /|\ /|\
                               |   |-----------------------------------|
                               |                                       |
                               |                                ThreadPoolExecutor类
                   ScheduledExecutorService 接口                       |
                              /|\                                      |
                               |                                       |
                               |----------------------------------------
                               |
                               |
                  ScheduledTheadPoolExecutor 类    
```
- 其实，计划线程池类，也我们定义一个普通的线程池是很类似的，也是继承自ExecutorService，只不过Scheduled又多了一层ScheduledExecutorService
- 定时任务有分为，固定时间间隔和固定时间时延的，面对的是不同的业务场景
- 固定时间间隔的任务不论每次任务花费多少时间，下次任务开始执行时间是确定的
- 固定延时间隔的任务是指每次执行完任务以后都延时一个固定的时间，但是每次任务的执行时长不确定，因而整体的周期也就不确定

### 任务返回值
- 我们同代码中可以看到，向计划线程池提交任务返回的是一个ScheduleFuture接口的对象，这是怎样一个对象呢
```text
  Delayed              Future            Runnale
    /|\                 /|\                /|\
     |------------------ |------------------|
                |                   |
                |                   |
          ScheduledFuture      RunnableFuture
               /|\                 /|\
                |-------------------|
                          |
                          |
                RunnableScheduledFuture
                         /|\
                          | 
                          |
                  ScheduledFutureTask
                  
```

### 执行流程
- 上面通过计划线程池的继承关系也看到了，其实它和普通的线程池真的很类似，只是它的队列是优先性质的阻塞队列，队列存储的是ScheduledFutureTask对象
- 每次从队列中通过task()方法获取任务(ScheduleFutureTask对象)，如果队列为空就阻塞
- 如果这个任务是时延任务，就应当回去应当延迟的时间，通过await去延时
- 如果这个任务是间隔任务，就计算下一次需要执行任务的时间，然后调用队列的add方法将任务入队，然后在进行task()操作
- 基本的流程就是再队列里使用add ,task.cancel的方式，对任务进行控制


### 优点
- 为什么用线程池，大家这个应该都知道，相比传统的Timer,即使有多个TimeTask,也只有一个线程能够执行，没有并发能力，资源的重复回收也会给GC压力
- 关于异常，Timer不会捕获TimeTask的异常，但是对于线程池可以自行进行资源的回收处理
- Timer是基于绝对时间的延时执行或周期执行，计划线程池是基于相对时间进行周期或延时操作
