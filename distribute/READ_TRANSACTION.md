### 一、分布式事务的特性ACID
- A ：原子性
> 原子性是描述一个分布式事务，在执行的过程中，需要被原子地执行，指所有分布式节点，要么都执行了，要么都不执行的特性；

- C ：一致性
> 一致性是分布式系统比较根基性的要求，当处理节点大于一个的时候，多个节点之间的数据一致、状态一致是一个非常关键问题。

>一致性又分为强一致性、弱一致性和最终一致性。

- I : 隔离性
> 隔离性指每一个事务的执行，在不同事务之间不能够相互影响，那在这个事务的执行过程中，可以依赖一些一致性算法来保证。

- D ：持久性
> 持久性指每一个事务对数据库的操作都是落实到磁盘的。


--------------------------------------------------

### 二、分布式事务产生的原因
1. 数据库的分库分表
2. 应用服务化SOA

--------------------------------------------------

### 三、分布式事务的理论
以下理论在分布式事务这边讨论，其实有一些都是分布式理论，同样作用于分布式存储等。

- 1.CAP理论
    - C：一致性，A：可用性，P：分区容错性；
    - 以上三点是对分布式系统很好的一个概括，可是在实际操作阶段，以上三点并不能够完全满足，需要牺牲其中一点来保证另外两点；

- 2.BASE理论
    - 基于CAP理论的不完美性，为了解决关系数据库强一致性引起的问题而引起的可用性降低而提出的解决方案；
    - Base理论有几个特性:基本可用、软状态、最终一致性（弱一致性的一种特例，存在一个不一致时间区）；
    
- 3.2PC理论：2RTT(propose+commit)
    - 两阶段提交是保证分布式事务的一个重要理论；
    - 两个阶段分为请求阶段和提交阶段，角色有协调者（coordinator）和事务参与者（participant）；
    - 首先是协调者通知/提议事务参与者同意或取消事务，每个事务参与者针对该事务在本地的执行，成功返回同意，失败返回取消。协调者统计，只有当所有的参与者都返回同意，才将真正执行该事务的命令下发提交，否则全部取消回滚；
    - 两阶段提交协议会存在协调者故障和参与者故障问题，需要依靠异步网络+节点宕机恢复的模型下实现一致性；
    
- 4.3PC理论:3RTT(propose+precommit+commit)
    - 三阶段提交协议主要增加一个确认提交的环节，避免了参与者的宕机情况；
    - 参与者宕机可能出现在三个阶段：下发提议、回应投票、执行投票结果；
    - 新增确认提交阶段，可以使协调者、参与者都能了解宕机节点的状态，而不会出现阻塞,增强了系统的可用性，对现实业务场景是非常值得的;
```text
看一下3PC在三阶段宕机的响应情况：
 - 阶段1: 
    - 协调者或watchdog未收到宕机参与者的投票结果，直接中止事务；
    - 宕机的参与者恢复后，读取logging发现未发出赞成投票，自行中止该次事务；
 - 阶段2: 
    - 协调者未收到宕机参与者的precommit ACK，但因为之前已经收到了宕机参与者的赞成反馈，协调者进行commit；watchdog可以通过问询其他参与者获得这些信息，过程同理；
    - 宕机的参与者恢复后发现收到precommit或已经发出赞成vote，则自行commit该次事务；
 - 阶段3: 
    - 即便协调者或watchdog未收到宕机参与者的commit ACK，也结束该次事务；
    - 宕机的参与者恢复后发现收到commit或者precommit，也将自行commit该次事务；
```

- 5.补偿事务理论（TCC）
  - TCC采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：
    - Try 阶段主要是对业务系统做检测及资源预留；（转帐中将双方账号冻结）
    - Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行Confirm阶段时，默认Confirm阶段是不会出错的；（远程调用转帐成功，解冻）
    - Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放；（转帐失败，将Try阶段远程调用解冻）
  - TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理；
  
- 6.队列MQ
  - 第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持；
  - 第一阶段Prepared消息，会拿到消息的地址；
  - 第二阶段执行本地事务；
  - 第三阶段通过第一阶段拿到的地址去访问消息，并修改状态；
       

--------------------------------------------------

### 四、分布式事务的解决方法
1.基于XA协议的两阶段提交
XA是一个分布式事务协议，由Tuxedo提出。XA中大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。

2.本地信息表
借助关系型数据库中的表，设计消费状态表，通过MQ或者轮询方式来检验状态。

3.消息非事务 +最终一致性
依靠MQ进行消息传递，通过重试机制进行失败操作的补救，需要记录日志、保证消费者调用业务的服务接口的幂等性。

4.消息事务+最终一致性
运用RocketMQ的消息事务的特点

5.TCC编程模式，补偿模式
> 运行3PC协议的特点，编写Try\Confirm\Cancel的代码，手动实现补偿

> 一般在支付接口里，调用系统中更新交易状态相关的服务，将订单更新为付款成功。同时，只有回调页面中输出了success字样或者标识业务处理成功相应状态码时，支付才会停止回调请求。否则，每间隔一段时间再向客户方发起回调请求，直到输出成功标识为止。

> 这是一个很典型的补偿例子，跟一些MQ重试补偿机制很类似。一般成熟的系统中，对于级别较高的服务和接口，整体的可用性通常都会很高。如果有些业务由于瞬时的网络故障或调用超时等问题，那么这种重试机制其实是非常有效的。

6.可以结合SOA框架，包括Dubbo、Spring Cloud等,对上游调用方接口调用做重试设置和超时设置。

--------------------------------------------------

### 五、应用
1. 在线支付
2. 在线下单

--------------------------------------------------

### 六、分布式事务：不控制、半控制、全控制
1. 不控制：不引入分布式事务的概念
2. 半控制：依靠消息事务+最终一致性或者补偿事务的方式实现，虽然牺牲了一部分数据一致性，实现最终一致性，但是能够保证一定的性能
3. 全控制：完全实现两阶段提交协议，牺牲性能，保证强一致性

