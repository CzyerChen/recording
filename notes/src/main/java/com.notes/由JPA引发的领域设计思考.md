> 之前学习了JPA和mybatis的对比，发现自己使用JPA还是停留再增删改查，自定义实现和一个一对多处理，一些视图操作和一二三级缓存还是一无所知

> JPA是采用了经典的领域设计模型，也是一脸懵逼，决定夯实一下这部分知识

> Clean架构  DCI架构  DDD/CQRS架构，六边形架构 ,这边考虑DDD/CQRS架构

> 结合大神的总结：[1](https://www.cnblogs.com/netfocus/archive/2012/02/12/2347938.html) ，[2](http://mdsa.51cto.com/art/201707/544029.htm)

> 将涉及到的一些例子，秒杀场景，订单流程，贴吧帖子模型，12306订票系统，这种架构上的设计原则其实不一定是看了定义就能熟悉的，确实需要很多的积累与个人的尝试与思考

> [更多DDD/CQRS学习资料](https://www.jianshu.com/p/edd8db46ea99)

### 基础知识

```text

Class Car{
   Wheel wheel;
   Tire tire;  
  }

Class Wheel{
   Position position;
}

Class Tire {
   Position position;
}

abstract Class Engine{

}

Class Customer{

}

```
#### 微服务架构 
了从业务角度拆分（职责分离）当前业务领域的不同业务模块到不同的服务，每个微服务之间的数据完全独立，它们之间的交互可以通过SOA RPC调用（耦合比较高），也可以通过EDA 消息驱动（耦合比较低）

#### CQRS架构
每个微服务内部，我们可以用CQRS/ES架构来实现，也可以用传统三次架构来实现

#### 聚合  -- 修改数据的最小单元 
它通过定义对象之间清晰的所属关系和边界来实现领域模型的内聚，并避免了错综复杂的难以维护的对象关系网的形成。聚合定义了一组具有内聚关系的相关对象的集合，我们把聚合看作是一个修改数据的最小原子单元

#### 聚合根  -- 管理聚合内的其他子对象（实体、值对象）
- 聚合根，每个聚合都有一个根对象，根对象管理聚合内的其他子对象（实体、值对象）
- 聚合之间的交互都是通过聚合根来交互，不能绕过聚合根去直接和聚合下的子实体进行交互
- Car、Wheel、Position、Tire四个对象构成一个聚合，其中Car是聚合根；Customer也是聚合根，Customer不能直接访问Car下的Tire（子实体），而是只能通过聚合根Car来访问
#### 聚合根、实体、值对象的区别
```text
1.聚合根具有全局的唯一标识，而实体只有在聚合内部有唯一的本地标识，值对象没有唯一标识

2.聚合根除了唯一标识外，其他所有状态信息都理论上可变；实体是可变的；值对象是只读的

3.聚合根有独立的生命周期，实体的生命周期从属于其所属的聚合，实体完全由其所属的聚合根负责管理维护；值对象无生命周期可言，因为只是一个值

```
#### 聚合根、实体、值对象对象之间如何建立关联？
```text
聚合根到聚合根：通过ID关联；

聚合根到其内部的实体，直接对象引用；

聚合根到值对象，直接对象引用；

实体对其他对象的引用规则：1）能引用其所属聚合内的聚合根、实体、值对象；2）能引用外部聚合根，但推荐以ID的方式关联，另外也可以关联某个外部聚合内的实体，但必须是ID关联，否则就出现同一个实体的引用被两个聚合根持有，这是不允许的，一个实体的引用只能被其所属的聚合根持有；

值对象对其他对象的引用规则：只需确保值对象是只读的即可，推荐值对象的所有属性都尽量是值对象
```
#### 区别聚合和聚合根
```text
订单模型：
订单：订单明细，客户信息，必须要具备这两种数据才能是一个正常的订单，向Order中增加明细，那么订单和订单明细ID和客户ID绑定，订单是一个聚合根

修改 Order的某个明细对应的商品的购买数量，从Order中移除某个明细，我们并不会对某一明细做查看，增删改，而是围绕订单开展，因而订单明细不是聚合根，订单明细是一个实体，绑定订单存在


贴吧帖子模型：
帖子:帖子，回复，他们是一对多的关系，我们这边会把帖子的删除设置为软删除，即并没真正删除一个帖子，

每一个回复是独立的，每一条回复绑定一个帖子ID作为外键，而不是帖子作为一个大对象，绑定了一个List的回复IDs
```
#### 聚合的一致性设计原则
- 聚合内的数据修改，是ACID强一致性的；跨聚合的数据修改，是最终一致性的。遵守这个原则，可以让我们最大化的降低并发冲突，从而最大化的提高整个系统的吞吐

#### In Memory 内存模型
n-Memory模式也是一种减少网络IO的一种设计，通过让所有生命周期还没结束的聚合根一直常驻在内存，从而实现当我们要修改某个聚合根时，不必再像传统的方式那样，先从db获取聚合根，再更新，完成后再保存到db了。

而是聚合根一直在内存，当Command Handler要修改某个聚合根时，直接从内存拿到该聚合根对象即可，不需要任何序列化反序列化或IO的操作。基于ES模式，我们不需要直接保存聚合根，而是只要简单的保存聚合根产生的事件即可。

当服务器断电要恢复聚合根时，则只要用事件溯源（Event Sourcing, ES）的方式恢复聚合根到最新状态即可

#### 事件溯源 Event Sourcing(ES) -- CRUD
```text
一个对象从创建开始到消亡会经历很多事件，以前我们是在每次对象参与完一个业务动作后把对象的最新状态持久化保存到数据库中，
也就是说我们的数据库中的数据是反映了对象的当前最新的状态。而事件溯源则相反，不是保存对象的最新状态，而是保存这个对象所经历的每个事件，
所有的由对象产生的事件会按照时间先后顺序有序的存放在数据库中
```

#### Actor模型 --- 消息形式
- 对象直接不会直接调用来通信，而是通过发消息来通信
- Akka框架就是实现Actor模型的并行开发框架，并且Akka框架融入了聚合、In-Memory、Event Sourcing这些概念。Actor非常适合作为DDD聚合根。Actor的状态修改是由事件驱动的，事件被持久化起来，然后通过Event Sourcing的技术，还原特定Actor的最新状态到内存

#### 事件驱动模型---Event-driven Architecture -EDA
```text
    Node1 ---- > Node2 ---- > Node3 --|
    /|\                               |
     |                               \|/
    Node6 < ---- Node5 < ---- Node4 --- 
```
- Node表示节点，每个节点负责处理逻辑；Event表示消息，节点之间通过消息进行通信。消息通过分布式消息队列如RocketMQ，Equeue进行通信。
- 不同于SOA架构，EDA架构是pub-sub模式；Node1处理完逻辑后产生消息，Node2订阅消息并进行处理，Node1不知道Node2的存在
- 最终一致性原则，Node1，Node2之间的数据一致性通过MQ最终保证一致
- 如何保证最终一致性（消息链不会断开）：1）MQ保证消息不丢；2）任何一个Node要保证自己完全处理完后才发送ACK给MQ；3）每个Node做到对任何消息处理的幂等性；
- 整个架构具有所有分布式MQ所带来的优点：如异步解耦、削峰、降低整个系统的整体部署成本；
```text
分布式消息队列：Kafka，RocketMQ，EQueue
能够将数据分入不同的broker,不同人对不同分区进行订阅，达到了很好地吞吐性能,Consumer从Broker拉取消息进行消费，并支持消费者负载均衡
```
#### 面向服务模型 -Service orentied Architecture SOA


### CQRS架构 --读写分离的架构思想 Command Query Responsibility Segregation 命令查询职责分离
- 可以借助MYSQL读写分离机制来理解
```text
 
                           CQRS/ES
                
    event storage
      存储事件
        /|\
         |                                      event handler
       events ---------------> 消息队列 ---------> 事件处理器
        事件                                          |
         |                                           \|/
   Command Handler                               data storage
      指令处理器                                      /|\
        /|\                                           |
         |                                           \|/
     message queue                               Read layer
       消息队列                                     facade
        /|\                                          /|\
         |                                           \|/
     command DTO                                  query DTO
        指令                                         查询
        /|\                                          /|\
         |                                            |
         |---------------------client<----------------|
         
 C端：引入Event Sourcing+In Memory架构思想
```
- CQRS架构中事件，表示命令操作领域中的聚合根，然后聚合根的状态发生变化后产生的事件
- 注意点
```text
一致性模型为最终一致性,不能完全保证数据是最新的：秒杀、12306购票等场景，用户UI上看到的数据总是旧的，看到的库存总是并发操作之前的数量，不代表你操作的那一刻还有很多数量
```
- 实现：
```text
代表有数据库的读写分离，系统底层存储不分离，但是上层逻辑代码分离，或者系统底层存储分离，C端采用Event Sourcing的技术，在EventStore中存储事件；Q端存储对象的最新状态，用于提供查询支持；
```
- 适用场景
```text
1.写模型和读模型差别比较大时；
2.希望实践DDD时；实现领域模型不受任何ORM框架带来的对象和数据库的阻抗失衡的影响；
3.对系统的查询性能和写入性能分开进行优化时，尤其是读/写比非常高的系统，CQ分离是必须的；
4.系统同时满足高并发的写、高并发的读的时候；做到C端最大化的写，Q端非常方便的提供可扩展的读模型；
```
- 使用方案三描述架构流程
```text
Command 流程  -- 写入 发送请求写入数据：

     修改数据请求
         |
        \|/
    command ->MQ
         |
        \|/
consumer 消费，调用command handler
         |
        \|/
 command handler 根据内部命令从指定聚合根ID
 从In Memory内存中直接获取根对象引用，
 然后操作聚合根对象
         |
        \|/
 聚合根对象状态变化，产生事件
         |
        \|/
  框架将自动持久化事件，
  存储到event storage
         |
        \|/
框架负责将事件达到event MQ
         |
        \|/
  event 订阅者订阅事件
交给event handler进行处理 


Query流程:  -- 查询 请求返回数据
     查询服务，传入条件
            |
           \|/
  查询服务从读库查询返回结果
   
   

```
- 非功能特性分析
```text
数据一致性模型 -- 最终一致性，分布式消息不会保证客户端消费的处理顺序，但是客户端消费的时候能够看到这个数据挥着操作的一个offset之类的标识，
                如果先收到了后面的数据，消费者就不应该立刻处理，而是先处理前面的消息
                一般消息队列比如kafka的客户端消费，都是客户端根据自身的offset的量来消费的，但是mysql binlog是由服务源端控制的绝对顺序
  
并发 并行 性能  --- 可以的话，并行换并发，并发会出现问题会比较棘手

消息幂等  --- KV判重，DB唯一索引

并发冲突处理  -- 并发中比较棘手的问题

扩展性  -- 可否动态扩展，数据能否均匀存储

可用性  --  遇到问题，能够保证一定程度的可用性，有没有高可用机制

瓶颈 伸缩性  -- 这个框架的瓶颈在于高性能的event store

```
- 并发的情况下，一个指令修改多个聚合根，通过DB事务保证强一致性
- 并行 -- 根据聚合根ID一级路由，对于同一个聚合根的操作会被路由到同一个机器上操作
- 并行 -- 经过以上一次路由，又经过了command mailbox经过了二次路由，也是根据聚合根ID，从而保证单个机器内，同一个聚合根的命令的处理是顺序线性的，从而避免了并发冲突
- 并发处理，幂等：利用唯一索引：1.聚合根ID + 事件版本号唯一；2. 聚合根ID + 命令ID唯一；

#### CQRS/ES client端的event sourcing事件溯源  AOF日志
- 优点：
```text
1.记录了数据的完整变化

2.可将数据还原到任意时间点

3.Domain event 有很大价值，对单表的检测可以预估未来情况

4.线上问题可以线下重演

5.可以将数据的ORM 转换为更为简便的OO

6.command event 可以追踪一个聚合根的变化过程

7.自动的并发冲突检测
```
- 缺点
```text
1.数据量过大，类似于AOF日志，是有一个比较好，就是每一次RDB快照都会触发一次AOF重写，调整日志结构，减少日志的大小，做一次瘦身

2.单个聚合根事件会过多

3.事件的修改需要兼容以前的结构

4.架构实践门槛高

5.需要具有DDD领域建模能力

6.事件驱动状态的修改

```

#### CQRS/ES架构的代码实现
- Command --- 一个框架层面的调用，发送 
- Event  --- 一个操作的实体
- Command Handler  --- 处理命令，根据命令创建一个聚合根：框架可以做到开发人员无需关注底层的技术问题，比如如何存储聚合根产生的事件，如何发布事件到MQ；彻底做到技术架构和业务逻辑分离
- Domain Aggregate --- Note:AggregateRoot<String> 
Note表示一个DDD聚合根，这里最核心的概念是：Note内部的状态的修改都是通过事件来驱动的，
也就是Note要做任何修改前，总是应该先产生事件，然后框架根据事件调用到对应的Handle方法，然后我们在Handle方法中修改Note的内部状态
- Event Handler  比如在同步MYSQL binlog的时候，会受到主库发来的event ,handler会解析出很多操作相关的数据

#### 一种DB实现的Event Store（CQRS的核心）设计思路
- 事件的高性能写入，大量事件存储，支持唯一索引
- 存储数据：先写日志再做数据修改
```text
事件顺序写文件
使用B+树存储索引信息
使用环形数组保存最近产生事件的聚合根ID
```
- 场景
1.写入事件
```text
检查事件是否符合唯一值索引（1.聚合根ID + 事件版本号唯一；2. 聚合根ID + 命令ID唯一；）

顺序写入事件数据到磁盘文件

异步更新事件索引到持久化文件

```
2.获取某个聚合根的事件索引
```text
从B+树快速获取索引数据，找到指定范围，去查找数据
```
3.重启时预热聚合根的索引信息到内存

#### 谈谈CQRS/ES的那些场景 -- 秒杀
- 流程
```text
1.浏览/搜索商品
2.查看商品详情
3.骄傲如购物车
4.结算
5.填写收货地址等
6.提交订单
7.支付
8.发货

```
- 订单实体
```text
1.订单处理中国
2.下单成功
3.买家已付款
4.卖家已发货
5.交易成功
6.交易关闭
7.退款的订单

```
- 秒杀：高并发订单处理-- 生成订单，预扣库存 关键在于高并发和高吞吐量
缓存记库存，队列放操作
```text
买家订单提交成功后，服务端首先在分布式缓存中检查商品的库存是否足够，如果不够，则立即返回并通知买家宝贝卖完了；如果足够，则发送下单的命令到MQ（异步处理订单）。
然后通知买家“您好，您的订单已收到，正在处理中。请稍后到我的订单中心查看订单处理结果。祝您购物愉快！”之类的提示。
```
订单结果
```text
订单未生成，则买家看不到订单，没关系，TA过一会儿刷新页面继续查看；
订单已生成，但是预扣库存还未有结果，则提示订单处理中，用户同样会等待；
订单已生成，预扣库存也已经有结果，不管库存是否足够，都显示相应状态给用户；
```
- 秒杀设计场景DDD CQRS架构典型的聚合根(Saga)的设计
```text
                                                     |----------------------  13.订单成功---------------------------|  |----------------12.库存占用确认-----------|      
                                                     |  |--------------------10.订单付款确认-----------------------| |  |  |------------11.确认占用库存------- |  |
                                                    \|/ |   \|/---------------9.确认付款-----------------------| \|/ | \|/ |                                 \|/ |
      |--------->1.展示订单 ---> command handler---> 订单分发 Aggregate -------2.订单处理------------> Order Process Manager 无状态 ----3.库存预定--> 库存分发Aggregate
      |                                              |    |   /|\----------- 5.确认预订----------------|   /|\     /|\-----------4.库存占用-----------|       
      |                              14.订单成功<-----|    |                                                  |
      |                                               6.订单预定确认                                           |
UI ---|                                                                                                       |
      |                                                                                                       |
      |                                                                                                       |
      |                                                                                                       |
      |                                                                                                       |
      |---------->7.创建付款 --> command Handler --> 付款分发Aggregate----------------------8.付款完成-----------|


其中有三个部分：订单系统  订单处理器 库存系统 ，订单处理器就是一个聚合根，职责是对流程进行建模，负责封装流程控制逻辑，而聚合根负责业务逻辑

传统会用简单的数据库事务来进行库存和金额的操作，但是在当下分布式服务中，则会用补偿事务或者消息队列的方式，解耦并增大数据库吞吐，结合缓存做库存的预定

```

#### 谈谈CQRS/ES的那些场景 -- 12306 
- 12306的业务逻辑比较困难：火车，座位，车次，站点，站点区间，车票
- 余票查询，订单
- 车票是一个车次某一站点，拥有作为的凭证
- [大佬的领域设计分析](http://www.cnblogs.com/netfocus/p/5187241.html),由于这个比较复杂，我觉得先啃秒杀的设计


### 传统架构，DDD/CQRS架构 对比
- 传统架构---三层架构
- DDD --- 经典四层架构

|属性|传统架构|CQRS架构|
|:----:|:----:|:----:|
|数据一致性|强一致性，数据库事务，但是分布式事务和分库分表的时候很难实现|最终一致性，部分事件接收数据是旧的，C端数据保持最新、做到数据强一致；Q端数据不必最新，通过C端的事件异步更新即可|
|扩展性|SOA架构，组件之间是强依赖紧耦合，都是对象之间直接方法调用|EDA架构，事件驱动的思想，低耦合，通过事件的方式异步进行数据同步|
|可用性|传统架构，读和写一体，需要把握读和写的并发和吞吐，代价大|CQRS架构只需要对于读或者写优化即可，充分利用分布式消息队列的优势：异步化、拉模式、削峰填谷、基于队列的水平扩展|
|性能/伸缩性|瓶颈在底层数据库的读写，分库分表|聚合根的性能，库的瓶颈，分库分表或者NoSql|


```text
目前大部分项目架构是还在SOA阶段，但是也有越来越多的项目往微服务方向转移，划分各个模块的功能，通过异步的队列或者异步RPC调用来实现操作的转移，并结合一些负载均衡的功能，提升项目的性能

应用场景是高并发写、高并发读、大数据，且希望在扩展性、可用性、性能、可伸缩性上表现更优秀，可以尝试CQRS架构

CQRS架构成熟的框架并不多，门槛很高，java平台有axon framework, jdon framework；.NET平台，ENode框架，高性能的分布式消息中间件也是一个门槛（java平台有RocketMQ），.NET平台我个人专门开发了一个分布式消息队列EQueue

CQRS中，Event Sourcing，消息重试，消息幂等处理，事件的顺序处理，并发控制，这些问题都比较复杂难处理

EDA架构体现了Reactive Programming（响应式编程）的思想
```
