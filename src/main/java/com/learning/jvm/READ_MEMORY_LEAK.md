- 内存泄漏是一个容易被忽视、一旦出问题就不太好解决的问题，关乎JVM的内存、关乎应用的存亡。
- JVM内存一个很好的朋友就是垃圾回收机制，它主要负责在应用生命周期以内，对内存数据碎片没有引用的部分，定期对它们进行回收再分配
- 但是当一些应用操作的失误、数据细节的忽视、资源未关闭等情况，会耗尽内存、降低系统性能，带来恶劣的结果。如果不处理，应用程序最终将耗尽其资源，最终以致命的java.lang.OutOfMemoryError终止。
                                                     
### 一、内存泄露的定义
内存泄漏是堆中存在不再使用的对象但垃圾收集器无法从内存中删除它们的情况

### 二、内存泄漏的症状
1. 应用程序长时间连续运行时性能严重下降
2. 应用程序中的OutOfMemoryError堆错误
3. 自发且奇怪的应用程序崩溃
4. 应用程序偶尔会耗尽连接对象

### 三、内存泄漏的类型
关于程序操作中，以下是可能使用到、又极易被忽略的情况，希望引起关注，做完美的coding.

1.Static字段
Static的类型会在程序初始化之后一直在内存中，直到程序终止，拥有与整个应用程序相匹配的生命周期，因而静态资源的定义需要谨慎；

- 预防：最大限度减少静态变量的使用；使用单例时，也避免使用立即加载的方式，而采用延时加载、用时加载；

2.未关闭的资源
包括数据库连接池、网络请求、读写文件、会话对象
- 预防：始终使用finally进行资源的关闭和回收、关闭资源的代码中不应该有异常或者继续捕获；了解一下try+with+resource;

3.不正确的equals和hashcode
特别是在自定义对象比较的时候，必须实现以上两个方法，不然程序将进入默认比较方法，耗费不必要的内存，类似与HashMap\HashSet，都会默认对key进行排重处理，觉得没有需要比较的地方但是却存在；

- 预防：在自定义实体的时候，都建议把equals hashcode方法写上；并且对于需要频繁比较的，更应该优化比较的方法；

4.引用了外部类的内部类
出于一些设计层面的问题，用到了外部类、内部类这样的设计，但是在使用中在不用外部类的时候，强行需要显示的new一个内部类，那么在使用内部类的时候其实会默认实例化一个外部类（这一个部分可以去看一下内部类的字节码，了解编译的时候内部类是如何实现访问的），并且这个实例的引用是隐式的；

- 预防：这种内部类的使用与他的设计方案是有冲突的，建议重新设计；

5.Finalize
这个方法是手动通过方法，将某个或某些对象进行垃圾回收，但是这个方法其实是将这个对象标记为可回收，去掉了它的所有引用，是否回收、何时回收都是依靠JVM自身的排队算法确定，因而会给人一种调用即回收了的错觉；
- 预防：避免使用finalize

6.字符串常量
字符串常量从永生代（PermGen）转换到堆空间，jdk7之前的字符串常量也是伴随程序的生命周期的，jdk7+就在堆上了；
- 预防：升级JDK版本；在使用长字符串的时候，加大永生代的大小；（-XX：MaxPermSize=512m）

7.ThreadLocal
本地Entry数组对ThreadLocal变量副本有一个弱引用，当当前线程不再存在，当前线程对Key的引用就会消失，可是ThreadLocal的弱引用还存在，因而无法被回收。
- 预防：手动调用remove方法，可以循环检验ThreadLocal的引用，并将其指向null；不要使用set(null)的方式来清除引用，因为无效；

### 四、内存检测工具
JProfiler
Profiling
Java VisualJVM





