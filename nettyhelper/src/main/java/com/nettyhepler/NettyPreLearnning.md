学习Java I/O模型，从BIO到NIO和Reactor模式

### 一、java IO模型
#### 1.同步IO/异步IO
- 同步IO是指请求必须顺序被执行，没有并行并发的操作，一个处理完处理下一个
- 异步IO是指多请求可以并发并行地执行，用户线程发起IO请求，内核IO完成后通知用户线程，或者使用用户线程地回调函数返回结果

#### 2.阻塞IO/非阻塞IO
- 阻塞IO，某个请求发出后，请求操作条件不满足就一直阻塞，直到满足条件才执行
- 非阻塞IO，某个请求如果不满足请求操作条件，就会返回条件不满足地消息，不会阻塞执行
- 阻塞并不等价于同步，而非阻塞并非等价于异步
- 阻塞和非阻塞重点在于请求的方法是否立即返回

### 二、Unix五种IO模型
- 阻塞IO
- 非阻塞IO
- IO多路复用
- 信号驱动IO
- 异步IO

#### 1.阻塞IO
分为两个阶段：
- 阶段1：等待数据就绪
  - 网络IO ，等待远端数据抵达
  - 磁盘IO ，等待磁盘数据读取到内核态内存中
  
- 阶段2：数据拷贝
  - 数据拷贝，就是由内核操作的，将数据从内核态内存，拷贝到用户态内存
  - 这么做是为了考虑系统安全，用户态线程没有权限操作内核态内存


### 2.非阻塞IO
分为三个阶段
- 阶段1：通知内核
  - socket通知内核，当前请求为非阻塞，不要把用户线程睡眠，直接返回错误码即可
- 阶段2：数据准备
  - 客户端的IO操作线程，虽然会因为异步返回码不被阻塞，但是由于数据还未准备好，IO操作线程还是会不断请求数据，轮询、重试，直到2获取数据
- 阶段3：数据拷贝
  - 数据准备完毕，内核就负责把数据从内核态内存拷贝到用户态内存
- 其中第二阶段的轮询会消耗大量CPU，因而不建议单独使用

### 3.IO多路复用
- IO多路复用是一个很好的想法，能够在单线程情况下，监视多个IOchannel的请求
- 会用到select poll函数，这两个函数能够阻塞多路IO，和阻塞IO不同
- 可以应对多路写、多路读的检测，直到有数据可读可写为止，才调用真正的IO线程去读写数据，减少了大量的重试和轮询
- 也是分为两个阶段：
    - 等待数据就绪：通过select/ poll 函数，监听多路channel，直到发现某一路数据就绪，具备读写的可能
    - 数据拷贝，通过某一路channel能够读写数据后，就将数据从内核态内存拷贝到用户态内存

### 4.信号驱动IO
- 允许socket进行信号驱动I/O，并安装一个信号处理函数，线程继续运行并不阻塞。当数据准备好时，线程会收到一个SIGIO 信号，可以在信号处理函数中调用I/O操作函数处理数据

#### 5.异步IO
- 阶段1：调用aio_read 函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回
- 阶段2：当内核将数据拷贝到缓冲区后，再通知应用程序
- 以上两个阶段都由内核完成，因而用户线程根本不用参与


#### 6.Java中四种IO模型
- 和unix相比，Java中仅有信号驱动IO的模型没有实现，其余均支持。
- 早提供的blocking I/O即是阻塞I/O，BIO
- 非阻塞I/O,NIO
- 通过NIO实现的Reactor模式即是I/O复用模型
- 通过AIO实现的Proactor模式即是异步I/O模型

### 从IO到NIO

面向流/面向缓冲

阻塞/非阻塞

选择器

零拷贝

NIO 之Channel、Buffer

NIO之Selector实现原理

### 阻塞IO下的服务器实现
单线程逐个处理所有请求

为每个请求创建一个线程

使用线程池处理请求

### Reactor模式
精典Reactor模式

多工作线程Reactor模式


多Reactor