- 之前每个redis学习中都提到了持久化机制，Redis呢也只有两种持久化机制，面对不同的问题，拥有不同的问题
- RDB负责全量快照备份，AOF负责增量指令重做
- RDB文件是二进制文件，可读性差，存储小，AOF文件是指令文件，可读性较高，冗余度大，存储很大，需要通过rewrite调整文件冗余度

### 持久化之快照原理
- redis是单线程的，在响应客户端请求的同时，还需要进行IO读写执行快照，这样既不阻塞客户端的请求，又可以执行持久化操作，redis如何实现呢？
- redis是使用操作系统的多线程COW-Copy on Write实现的快照持久化

### 持久化之fork
- 也有看到别的持久化文章说到，redis是通过异步fork子线程去完成的持久化操作，那这个具体是怎么实现的呢？
- redis在持久化的时候会调用glibc函数fork紫禁城，快照持久化就是由这个子进程负责的，因而父进程可以继续处理客户端的请求
- 子进程刚产生的时候，是由与父进程共享数据和代码段的
- 有人会问，既然数据共享，子进程是去遍历读取写入RDB文件，但是父进程可能正好修改了数据，这样数据不就乱了吗？
- 这时候就利用到了COW的功能将数据段页面分离，在父进程修改数据之前，它会将当前页复制一份，保证子进程读到的是原来的数据，而自己修改的是另一份数据
- 由于数据的修改始终是一部分，只有极少数全部删除，批量新增会出现页面分离，其他情况基本不会，redis中页面只有4K

### 持久化之AOF
- AOF相比RDB，是一种安全但又日志繁重、执行缓慢的持久化方式
- 它会将redis所有指令都记录下来变成序列，这个指令只包括对内存进行修改的部分，然后通过读取日志文件，重放指令，来恢复
- 这种方式相当繁重，因为长时间操作下，前期命令都成为了废命令，没有执行的价值，但还是占用了大量的文件空间，不得不重做
- AOF的文件写入是在命令操作无误之后才写入的，这种规则和hbase不一样

### 持久化之AOF重写
- 上面有提到，AOF的日志文件经年累月，会越来越多，并且废指令占了大部分，那么可以通过重写清洗指令
- bgrewriteaof 指令用于AOF日志瘦身，它会开辟子线程对内存遍历，重新生成当前内存状态指令，写入一个新的AOF文件。操作完毕之后再将新的AOF文件追加在后面

### 持久化之Fsync
- 这个命令是用来将指定文件的内容强制从内核缓存刷新到磁盘上
- 例如一个写操作执行后，会将指令内容写道内核，内核将异步脏数据刷回到磁盘，但是为了保证内核缓存中的数据能够及时的写道磁盘，就可以用命令
- 通常情况下，这个命令是1S执行一次，因为这个命令毕竟是一次磁盘IO操作，因而不可能每来一个操作就执行一次，因而这样每秒执行一次的操作可以算是一个折中了

### 持久化策略
- 以上和以往经验来看，RDB和AOF都不能单独使用，会有不同的弊端，当然对持久化数据要求不高的可以用RDB随意
- 但是如果对持久化要求高的，那自然数据一个也不能多一个也不能少
- 从redis 4.0开始就可以使用混合持久化方案，将从索引0-当前索引，创造一个最大化RDB快照，再将RDB快照后最当前的索引之间的通过AOF日志文件记录，这样重放内存也会较快，数据也能保证完整性

### [更多](https://mp.weixin.qq.com/s?__biz=MzA3MTUzOTcxOQ==&mid=2452965876&idx=1&sn=8e652ab31b628af89b275cf8f25544ef&scene=21#wechat_redirect)



