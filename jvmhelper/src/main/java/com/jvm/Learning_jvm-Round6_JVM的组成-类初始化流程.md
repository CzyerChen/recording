### 一、JVM整体组成可以分为4部分
1. 类加载器（ClassLoader）
2. 运行时数据区（Runtime Data Area）
3. 执行引擎（Execution Engine）
4. 本地库接口（Native Interface）

- 程序在执行之前先要把java代码转换成字节码（class文件）
- jvm首先需要把字节码通过一定的方式 类加载器（ClassLoader） 把文件加载到内存中 运行时数据区（Runtime Data Area）
- 而字节码文件是jvm的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器 执行引擎（Execution Engine） 将字节码翻译成底层系统指令再交由CPU去执行
- 而这个过程中需要调用其他语言的接口 本地库接口（Native Interface） 来实现整个程序的功能
- 这就是这4个主要组成部分的职责与功能

//========================================================================//
- 我们通常说的组成部分就是运行数据区的组成部分：

|序号|名称|说明|特点|
|:---:|:---:|:---:|:---:|
|1	|程序计数器（Program Counter Register）|	线程所执行的字节码的行号指示器|	特性：内存私有	异常规定：无|
|2	|Java虚拟机栈（Java Virtual Machine Stacks）	|描述的是Java方法执行的内存模型，每个方法在执行的同时都会创建一个线帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息	|特性：内存私有，它的生命周期和线程相同	异常规定：StackOverflowError、OutOfMemoryError
|3	|本地方法栈（Native Method Stack）	|本地方法栈是为虚拟机调用Native方法服务的	|特性：内存私有，它的生命周期和线程相同	异常规定：StackOverflowError、OutOfMemoryError
|4	|Java堆（Java Heap）|类实例区：Java堆唯一的目的就是存放对象实例	|特性：内存共享	异常规定：OutOfMemoryError
|5	|方法区（Methed Area）	|用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据	|特性：内存共享	异常规定：OutOfMemoryError


### 二、Java 创建对象的过程
- 之前有提到JVM类加载的一个流程，这个是JAVA 对象初始化的外部流程

1.类加载检查： 
- 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，
- 并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

2.分配内存： 
- 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。
- 对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。
- 分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，
- 而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。

3.初始化零值： 
- 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），
- 这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值

4.设置对象头： 
- 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。
- 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式

5.执行 init 方法： 
- 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。
- 所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

### 三、内存分配有哪些策略？
#### 指针碰撞：
- 适合场景：堆内存规整无碎片的情况（那肯定不适合标记清除的回收器）
- 原理：用过的内存整合到一边，没有用的放到另一边，中间有一个分界指针，只需要向没有用过的方向将该指针移动内存大小位置即可（标记整理/复制适合的）
- GC回收器：Serial（单线程复制） ParNew (Serial+多线程复制)

#### 空闲列表：
- 适合场景：内存不规整的情况（存在内存碎片的标记清除算法）
- 原理：虚拟机会维护一个列表，该列表中内存块哪些可用，着一块足够大的内存块分配给实例就可以了，最后刷新列表
- GC收集器：CMS（标记清除的收集器）

### 四、并发分配内存的方法:
#### CAS+失败重试： 
- CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。

#### TLAB
- 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配


### 五、对象的内存布局是什么样？
- 在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：对象头、实例数据和对齐填充
#### 对象头
- Hotspot虚拟机的对象头包括两部分信息
- 第一部分用于存储对象自身的自身运行时数据（哈希码、GC分代年龄、锁状态标志等等），
- 另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。

#### 实例数据部分
- 是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。

#### 对齐填充部分
- 不是必然存在的，也没有什么特别的含义，仅仅起占位作用
 - 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍
 - 而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。



### 六、对象的访问有哪些方式？
- 句柄或者直接指针
#### 句柄
- 句柄需要一个堆上的句柄池来存储句柄，栈上的reference指向句柄池中的对象实例数据地址和类型数据地址，再由句柄池中对象指向真实的数据，真是数据改了不需要reference的修改，只需要修改句柄池中的指针，相对稳定

#### 直接指针
- 就是reference直接指向内存中对象地址，没有中间环节，访问效率快，节省了一次指针定位的时间开销


### 七、String的对象创建
1.通过双引号或者intern创建的对象在常量池，intern 是一个 Native 方法
- 它的作用是：如果运行时常量池中已经包含一个等于此 String 对象内容的字符串，则返回常量池中该字符串的引用
- 如果没有，则在常量池中创建与此 String 内容相同的字符串，并返回常量池中创建的字符串的引用

2.字符串拼接
```text
          String str1 = "str";
          String str2 = "ing";

          String str3 = "str" + "ing";//常量池中的对象
          String str4 = str1 + str2; //在堆上创建的新的对象      
          String str5 = "string";//常量池中的对象
          System.out.println(str3 == str4);//false
          System.out.println(str3 == str5);//true
          System.out.println(str4 == str5);//false

```
          

3.String s1 = new String("abc");这句话创建了几个对象？
- 两个，常量池一个abc 然后 new 了一份字符串"abc"放入Java堆
- 字符串常量"abc"在编译期就已经确定放入常量池，而 Java 堆上的"abc"是在运行期初始化阶段才确定
