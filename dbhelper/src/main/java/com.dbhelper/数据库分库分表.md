分库分表涉及关系型数据库，产生的问题主要有：
- 什么是分库分表？
- 何时、怎样进行分库分表？
- 主键ID如何处理？
- 分库分表之后有哪些注意点？
- 如何做线上部署？
- 有哪些实践？
- 推文来自于[架构之路][码洞][程序猿DD][芋道源码][ 民工哥技术之路][Java知音][数据和云][架构师小秘圈]


### 一、前提
- 数据库的存储容量有限，单表的容量控制在1KW，如果超出这样的数量级就需要做其他处理
- 在数据实在存储不下的情况下，肯定会寻求解决办法：分区；分库分表；NOSQL；NEWSQL
- 当下比较新鲜，动态扩容效果好，吞吐量由大的要数NOSQL 和NEWSQL了，那么既然有了这样的数据存储解决方案，为什么还要选择关系型数据库呢？
- 理由其实不难理解：
```text
RDBMS 在业内有了几十年的数据存储管理的积累，自然是比后起之秀更加稳定可靠，生态完善，拥有事务的特征
RDBMS 在业内，任然是占有最大份额，并且短期拥有不可撼动的地位，很多业务的对接和处理也是只能用RDBMS
```
- 因而，虽然NOSQL 和NEWSQL有很大魅力，短期的解决方案还是RDBMS为主，后起之秀为辅的存储方案
- 互联网公司又以MySQL为主，国企&银行等的企业以Oracle/DB2为主

### 二、分区表方案
```text
 分区表：
 分区表是由多个相关的底层表实现，这些底层表也是由句柄对象表示
 存储引擎管理分区的各个底层表和管理普通表一样，分区表的索引只是在各个底层表上各自加上一个相同的索引
 
 缺点
 单机资源有限，比如连接数，吞吐量，并发等
 无法使用外键，不支持全文索引
```
- 业务场景：数据不是海量（分区数有限，存储能力就有限），并发能力要求不高

### 三、分库分表方案
#### 1.核心方案
分库分表处理海量核心数据的方案有以下几个：
```text
阿里的TDDL，DRDS和cobar，开源社区的sharding-jdbc（3.x已经更名为sharding-sphere），MyCAT，360的Atlas，美团的zebra
 
1.Cobar Cobar-client --- 提供类似mysql分布式服务的中间件 ，属于中间层服务
 
2.Mycat --- 在cobar的基础上的二次开发，解决了Cobar的一些问题，也加入了自己的特性，后端可以支持mysql sql server Oracle DB2 PostgreSQL 等主流数据库
 
3.TDDL --- 根据淘宝自己业务开发的，主要解决了分库分表对应用的透明化和异构数据库之间的数据复制
 
4.DRDS --- 阿里的分布式数据库服务
 
5.Atlas  ---- 一个用程序与Mysql协议的数据中间层项目，360团队是将mysql proxy 的lua用c改写
 
6.DBproxy ---- 美团点评的，在Atlas上做了很多改进
 
7.sharding-jdbc  ---- 当当的开源项目，目前托管在Apache,在应用框架ddframe中，从关系型数据库模块dd-rdb中分离出的数据库水平分片框架，实现透明化数据库分库分表访问
* 是一个轻型java框架，使用客户端直连，以jar包形式提供服务，无proxy代理曾，无需额外部署，无其他以来
* 分片灵活，支持等号 between in等多维度分片，也支持多分片键
* sql功能健全，支持聚合分组排序，limit or等查询，并支持building table或者笛卡儿积的方式查询
```
- 后面对于每一个分库分表的特点会进行学习，对于sharding-jdbc和mycat进行源码学习

#### 2.拆分方式
- 数据库分库分表可以分为水平拆分和垂直拆分
- 垂直拆分----保证单库单表，一个数据库只服务于一个表
- 水平拆分，比如分到两个节点，单数分到节点1存储，双数分到节点2存储


#### 3.分库分表的模式：
1.Client：  阿里的TDDL，sharding-jdbc
client模式作用在客户端，可能是一些jar，然后提供联通数据的能力
```text
    |--------------|
    |    应用      |
    | sharding-jdbc|
    |--------------|
           |
           |
          \|/
           DB
```
2.Proxy ： 阿里的cobar，MyCAT， sharding-sphere
代理模式是需要一个中间件层的一个转发或者处理，来获取数据联通的能力
```text
   |------------|
   |    应用     |
   |------------|
         |
         |
        \|/
   |------------|
   |   cobar    |
   |------------|
         |
         |
        \|/
        DB
```
3.不论是client还是proxy模式，都需要经过以下步骤，将我们常用的sql进行分发和结果处理：SQL解析 ---> 重写 ---> 路由 ---> 执行 ---> 结果归并

#### 4.分库分表案例
- 一些典型的分库分表的存储：订单表（量大，并且没有最大只有更大的情况，还有一些运行数据记录的表，是在持续写入的），用户表（总数较大，但是是可以预估的）
- 选择sharding-column
```text
sharding-column是和你业务所需的字段，比如一些关注度比较高，容易被查询的字段，例如ID、分类
```
- 处理思路：
```text
只选取一个sharding column进行分库分表 ；
  
多个sharding column多个分库分表；
 
sharding column分库分表 + es
```

1.订单表设计
```text
order_id       订单ID
user_id        用户ID
merchant_code  商家代码
order_count    订单数
order_time     下单时间
remark         备注
```
- 其中order_id user_id marchant_code是经常被查询的字段
- 冗余类型:
```text
冗余全量：每个sharding列对应的表的数据都是全量的，这样做的优点是不需要二次查询，性能更好
缺点：空间换时间，会消耗大量冗余的存储空间
 
冗余关系索引表:
只有一个sharding column的分库分表的数据是全量的
其他分库分表只是与这个sharding column的关系表

优点:节省空间
缺点:除了第一个sharding column的查询，其他sharding column的查询都需要二次查询

```
- 冗余全量和冗余关系的对比
```text
1.速度对比：冗余全量表速度更快，冗余关系表需要二次查询，即使有引入缓存，还是多一次网络开销；

2.存储成本：冗余全量表需要几倍于冗余关系表的存储成本；

3.维护代价：冗余全量表维护代价更大，涉及到数据变更时，多张表都要进行修改
```
在当今有专业运维团队，并且硬件存储相对廉价的时代，全量冗余获取会是大多数人的选择，阿里的订单表也采用的是全量冗余


2.用户表设计
```text
user_id      用户id
mobile_no    手机号
email        邮件
usernmae     用户名
remark       备注
```
- 以上字段中 mobile_no email username user_id都是业务中需要频繁访问的字段


3.账户表设计
```text
account_no
available_amount 
frozen_amount
status
remark
```
采用补偿的机制来设计账户表，其中常用的字段是account_no

#### 5.es检索，减轻sharding的压力
- sharding_column越多，整体查询的效率就会越低，也会受各部分数据的限制
- 因而，很多方案会采取单表单sharding_column，然后利用es的全量冗余数据执行检索，各取所长，以nosql为辅助
- 单sharding_coulmn+es+hbase：单sharding_column用作针对sharding_column业务检索，es负责其余复杂检索任务,包含所有需要的检索项，通过es的索引获取对象ID,更多完整数据，可以通过es返回的ID，去HBASE极速读取全部数据
- es+hbase是一个很容易理解的解决方案，业内有solr+hbase的高度集成，索引的一致性问题，solar+hbase也提出了Lily hbase indexer解决方案
- 因而单sharding_column+solr+hbase是一个海量数据存储的一个非常典型的方案
