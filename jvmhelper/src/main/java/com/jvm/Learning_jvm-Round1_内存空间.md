### java如何编译.java文件
- JavaJ源文件（.java） —->编译器  —->字节码文件 (.class)
- 字节码文件(.class) —->JVM —->机器码
- java的平台无关性就在于第二步，.class文件能够在不同的平台上，在相同的虚拟机中，被不同的解释器解释，转换成适配可执行的机器码
 

### 内存空间 -- 运行时数据区
#### 1.线程
- JVM中的线程与操作系统的线程有直接映射关系
- 线程的本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好了以后，会创建一个操作系统原生线程，java线程结束，操作系统线程也被回收了。
- 操作系统调度所有线程，将他们按照操作系统的线程管理策略进行线程的调度和管理，分配到不同的CPU上执行。
- 操作系统线程初始化完毕，就会调用java线程的run方法
**JVM后台的几个系统线程**：

|线程|作用|
|:------:|:-----:|
|虚拟机线程|负责等待JVM到达安全点操作出现：这些操作的类型有：stop-the-world 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除|
|周期性任务线程|负责定时器任务|
|GC线程|支持JVM中的GC活动|
|编译器线程|将字节码动态编译成本地平台机器码|
|信号分发线程|接收发送JVM信号并调用适当的JVM方法处理|

#### 2.JVM内存区域
- 线程私有：程序计数器和虚拟机栈，本地方法栈，线程共享：（类实例区）堆和方法区
//-------------------------线程私有-------------------------//
- 程序计数器：指向虚拟机字节码指令的位置，如果执行的是本地指令则为空，是唯一一个没有OOM的区域
- 虚拟机栈-->栈帧  -Xss
```text
1. 虚拟机栈和县城的生命周期一致

2.一个线程中，每调用一个方法就创建一个栈帧

3.栈帧包含：本地变量表（局部变量表），操作数栈、动态链接、方法出口，对运行常量池的引用

4.可能出现的异常：栈的深度超出JVM允许的深度StackOverFlowError , JVM允许动态扩展，可是栈内内存超出能够申请的最大内存，会出现Out Of Memory Error

```
- 本地方法栈(主要是针对于执行本地方法，会出现关于本地内存引用的异常StackOverFlowError Out Of Memory Error )
//----------------------------线程共享------------------------//
- 类实例区（java堆)  -Xms -Xmx
```text
新生代 eden / to survivor/from survivor

老年代 

异常  OOM

```
- 方法区，运行时常量池  --- 永久代，伴随程序的始和终
```text
Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池

用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中

```
- 直接内存（不归JVM GC管） --- 主要在于Netty的广泛使用，更多的使用直接内存来优化传输的效率，使用了基于Channel和Buffer的 IO当时，使用Native函数库直接分配堆外内存，使用DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据, 因此在一些场景中可以显著提高性能


#### JVM的堆：新生代 1/3（eden/to survivor/from survivor ）和老年代 2/3
- 一般新生代会给1/3的内存，由于对象的频繁创建，会频繁出发MinorGC进行垃圾回收。
- Eden:新对象的分配地，如果对象过大，应该直接放入老年代，如果分配的对象内存不够会出发MinorGC
- Survivor From,上一次GC的幸存者，此次GC的被扫瞄者
- Suvivor To:保留了一次MinorGC过程中的幸存者
- MinorGC过程（针对新生代）：采用复制算法
```text
1. eden、servicorFrom 存货的对象复制到ServicorTo，年龄+1，其中满足需求需要移到老年代的就移入老年代

2.清空eden、servicorFrom

3.ServicorTo和ServicorFrom互换，，原ServicorTo成为下一次GC时的ServicorFrom区

```
#### JVM堆：老年代
- 老年代一般是长期会使用的对象存放在堆上，不会频繁进行MajorGC,MajorGC前一般都先进行了一次MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发,或者一个大对象的写入
- MajorGC采用标记清除方法，一次回收耗时较长，并且在内存清除后容易产生内存碎片

#### 永久代（方法区）
- 指内存的永久保存区域，主要存放Class和Meta（元数据）的信息,Class在被加载的时候被放入永久区域，它和和存放实例的区域不同,GC不会在主程序运行期对永久区域进行清理
- 永久代在jdk8之后归入元数据区，作用在本地，而不在JVM中了，仅受本地内存影响
- 类的元数据放入 native memory, 字符串池和类的静态变量放入java堆中
