- 看完了重排序，是编译器和处理器增强计算并行度的一个手段
- 也看到了因为重排序，多线程操作可能出现结果违反直觉的情况
- 接下来我们就将慢慢了解那些能保证执行顺序的操作

#### 1. 数据竞争
- 多个线程对于主存中的一个变量，会进行读写的操作，如果各自线程的本地内存中都不能第一时间同步主存中的数据并原子地刷新，就会出现数据竞争的问题
- 出现数据竞争，那么执行结果就没有保障
- 这里的同步是指广义上的同步，包括对常用同步原语（lock，volatile 和 final）的正确使用

#### 2. 顺序一致性内存模型
- 顺序一致性内存模型是一个被计算机科学家理想化了的理论参考模型，它为程序员提供了极强的内存可见性保证
- 两大特性:
    - 一个线程中的所有操作必须按照程序的顺序来执行
    - 有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见
- 概念上，顺序一致性模型有一个单一的全局内存，在任意时间点最多只能有一个线程可以连接到内存。当多个线程并发执行时，所有线程的所有内存读 / 写操作都会被串行化。
- 同步程序执行
```text
(A1   A2   A3)-------
                    |
                    |
                    |--------(A1   A2   A3)(B1   B2   B3)
                    |           监视器           监视器
                    |         操作整体有序，内部程序顺序不变
(B1   B2   B3)-------                    

```
- 未同步程序执行
```text
(A1   A2   A3)-------
                    |
                    |
                    |--------(B1)  ( A1   A2)(A33)  (B2   B3)
                    |                      
                    |         操作整体无序，内部程序顺序不变
(B1   B2   B3)-------                    

```

#### 3. 同步程序的顺序一致性效果
- 在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门
- 允许在多个临界区之内重排序，而多个临界区之间需要采取顺序一致性


#### 4.未同步的执行特性
- 对于未同步或未正确同步的多线程程序，JMM 只提供最小安全性。程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false
- JMM 不保证未同步程序的执行结果与该程序在顺序一致性模型中的执行结果一致
- JMM 不保证对 64 位的 long 型和 double 型变量的读 / 写操作具有原子性，而顺序一致性模型保证对所有的内存读 / 写操作都具有原子性
- 总线事务包括读事务（read transaction）和写事务（write transaction）
- 在一个处理器执行总线事务期间，总线会禁止其它所有的处理器和 I/O 设备执行内存的读 / 写
- 总线的这些工作机制可以把所有处理器对内存的访问以串行化的方式来执行；在任意时间点，最多只能有一个处理器能访问内存。这个特性确保了单个总线事务之中的内存读 / 写操作具有原子性