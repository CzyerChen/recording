主要介绍jvm\jdk\redis等缓存技术

### redis
redis是K-V类型的内存数据库，支持多种数据类型，事务支持较弱，用来缓存数据或者存储数据

- 1.redis的使用场景
  - 程序计数器
  - 排行榜按照等级或者得分排名
  - 存储时间戳
  - 记录用户信息，或者用户操作信息
  - 社交列表，点赞列表、收藏列表、关注列表
  - 缓存，缓存热点数据，更新的资讯...
  - 队列，利用它分布式的特点，做一个消息队列，lpoop,lpush
  - 会话缓存，缓存web的session
  
- 2.redis中的数据结构
  - String,应用数，资讯 
  - hash，用户粉丝列表，用户点赞
  - list,消息队列
  - SortedSet(有序集合)，排名，热门列表

- 3.redis为什么这么快
  - 完全基于内存操作，减少IO操作
  - 数据结构相对简单
  - 采用单线程进行操作的执行，避免了上下文切换，CPU的过多消耗
  - 使用IO复用模型，利用非阻塞IO
  
- 4.redis的哨兵模式
  - 哨兵模式主要通过在redis集群的基础之上，运行1个以上的哨兵节点，用以观察整个集群的健康状况、主持节点选举、内部节点状态同步，也用于与应用程序通信
  - 哨兵模式是redis高可用的保障

- 5.redis存在的问题
  - 缓存雪崩
  
  缓存雪崩，是指缓存有缓存过期时间，当一个时间点，大部分缓存同时过期，那请求的压力就直接作用在DB上，可能会造成D崩溃
  - 缓存穿透
  
  缓存穿透，是指当某一数据类型的key为null时，缓存查询无效即会去DB查询，如果此查询反复查询，则造成SQL注入，即带来DB崩溃，有部分攻击就采用了此种手段
  
  可以通过1)缓存NULL key值，2) 使用布隆过滤器

- 6.redis持久化机制 
  - RDB
    - 该机制在指定时间间隔将内存数据集快照写入磁盘
    - 优点： 可以灵活处理日期归档这些操作，容灾恢复可以较快，性能能够最大化，只需要一个子进程去做持久化的工作
    - 缺点： 不能保证数据的高可用性，不能够百分百保证数据的完整性，数据较大的情况，子进程执行任务可能会导致服务的停顿
    
  - AOP
    - 通过日志的形式，记录服务器多处理的所有写操作，在redis服务器启动之初将日志文件全部重做，恢复状态
    - 优点：最大程度保证了数据的安全性，有完整的擦偶作日志文件，可以清晰的回溯redis的每一项操作
    - 缺点当数据操作量很大的时候，启动重做日志会比较慢，并且AOP文件会比RDB文件大，AOP的运行效率比RDB慢，但是每秒同步效率是比较高的
  
  - 无持久化
  
  - 关于数据持久化策略:
    - 采用RDB（redis默认策略），因为RDB是在指定时间间隔就会生成数据文件，我们可以定时通过系统crob job方式拷贝生成的数据文件，作为备份
    - 采用AOF,需要通过appendonly 设置为yes,因为AOF模式下就是redis自动启动rewrite机制，使用append模式将数据的修改不断更新到数据库。通过以上设置
    就可以生成一个AOF文件，下一次启动就可以将AOF文件重读重做了
    - 类似于数据库，它也支持定期快照，并且可以设置快照的频率
      - 流程：开启子线程，子线程将快照数据写入临时RDB文件中，当子进程完成数据写入操作后，再用临时文件替代老文件
  
- 7.redis集群的数据同步机制
  这里的数据同步机制，主要描述的是redis集群数据的主从复制
  - 主节点和复制节点的数据同步都是非阻塞的方式
  - 主节点做一次bgsave,然后同步将操作记录到内存buffer中，待完成后将rdb文件，全量同步到复制节点
  - 复制节点接受完，将rdb镜像文件加载到内存
  - 加载完成后，主节点在将同步期间的操作在同步给复制节点重放
  - 写操作只从主节点入， 复制节点协助主节点执行读操作
  - 如果主节点和复制节点出现断连的现象，复制节点会自动重连，并做一次完全同步
  
- 8.redis分布式锁
  - 分布式锁的场景:一连串连贯的动作需要被统一的执行，例如下订单等，需要对某些数据进行锁的操作
  - 锁的措施：
    - 可以使用 SELECT FOR UPDATE 行级锁来实现
    - synchronized 关键字
    - Redis 分布式锁
  - redis命令1：SETNX：用来加锁
    - 将key设置值为value，如果key不存在，这种情况下等同SET命令。 当key存在时，什么也不做。SETNX是”SET if Not Exists”的简写
  - redis命令2：GETSET ：用来解决死锁，将原来的锁替换成新锁
    - 自动将key的值设置为value并且返回原来key对应的value。如果key存在但是对应的value不是字符串，就返回错误;如果key不存在,就返回null
    

- 9.redis的事务机制
  - redis虽然对事务的支持没有很完善，但是也有事务机制，如同众多数据库一样
  - 事务就是为了保证一组数据操作被原子的执行（要么都做，要么都不做），保证数据的正确性
  - 因为redis是单线程的操作，因而操作都会被串行执行，没有其他分布式事务的事务提交复杂性，对于某一条操作执行失败，并不会影响和阻塞后续的操作
  - 通过MULTI开启事务
  - 通过EXEC/DISCARD提交/回滚事务
  - 通过WATCH监视一个(或多个) key

- 10.redis AOF redis-check-aof 用于检测AOF文件中的数据不一致错误，并且进行对应修复，保证AOF文件执行的正确性

- 11.基于redis实现锁服务
  - 秒杀场景：就是在几乎并发的情况下，争抢资源，涉及到的实现就是关于锁方面
    - 可以使用的方法有： 使用同步方法锁住对应的代码块/方法，或者将执行操作串行化
    - 但是在秒杀这种高并发的情况下，加锁肯定会使资源耗尽，关于串行操作，对于争抢不同的商品使用同一个队列也是不合理的
    - 可行的解决方案就是在不同商品上加上互斥锁，这样可以实现抢购同一个商品的线程会被互斥锁作用，不同的商品没有影响
    - 除了在关系库中使用互斥锁，实现秒杀的场景，还可以使用分布式锁，直接将请求进行分摊
    - cachelock lockedObject LockedComplexObject CacheLockInterceptor  lock unlock 
    - 秒杀实际场景的练习

- 12.redis 安装
  - windows 下载安装包，使用`redis-server.exe redis.windows.conf`开启系统服务
  - linux 安装单机版（测试版本）、集群版（分布式副本版本）、哨兵版（高可用版本）

- 13.redis基础知识学习（基础概念、安装、命令、数据类型等）  --- 感觉非常详细，适合初学者
 https://www.cnblogs.com/arjenlee/p/9238114.html
 
 
