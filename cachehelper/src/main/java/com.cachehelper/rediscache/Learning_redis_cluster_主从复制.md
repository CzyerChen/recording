- redis 多节点模式有哨兵模式和集群模式，哨兵模式的服务节点是全量复制，集群模式的服务节点是分片存储
- 经历几个阶段，初始化复制，增量复制等
- 跟随推文学习，redis主从复制的原理，包括复制过程，数据之间的同步，全量复制的流程，部分复制的流程，心跳设计，异步复制流程


### 一、复制流程
```text
1. 从节点执行 slaveof 127.0.0.1:6379
               |
               |
              \|/
2. 从节点保存主节点的信息，还未进行发起复制
               |
               |
              \|/
3.从节点通过内部定时任务扫描到主节点的信息，主从建立socket连接
               |
               |
              \|/
4.从节点向主节点发送Ping命令，直到收到主节点的pong响应,否则重连
               |
               |
              \|/
5.主节点的权限认证，认证失败->复制终止
               |
               |
              \|/
6.同步数据集，主节点将所有数据发送给从节点 ---耗时长
               |
               |
              \|/
  7.主节点持续将当前写命令发送给从节点
               |
               |
              \|/
          master 6379
```
### 二、数据间的同步---同步数据集
- 同步命令：sync(redis 2.8之前)/ psync(redis 2.8之前)
- psync命令
```text
psync  {runId}  {offset}

runId：从节点所复制主节点的运行 id
offset：当前从节点已复制的数据偏移量

```
- psync执行流程
```text
从节点发送 psync  {runId}  {offset} ，runID是主节点的唯一ID，默认-1，offset是数据偏移量，默认-1

主节点接收到从节点信息，根据参数回复
1： +FULLRESYNC {runId} {offset} 从节点将触发全量复制流程

2： +CONTINUE，从节点将触发部分复制

3:  +ERR，说明主节点不支持 2.8 的 psync 命令，将使用 sync 执行全量复制
```

- psync的组件


1.主从节点各自复制偏移量
- 主从节点都各自维护自己的复制偏移量
- 主节点处理完写入命令后，将命令的长度累加，统计信息在 info replication 中的 masterreploffset 指标中
- 从节点每秒上报自己的复制偏移量给主节点，主节点会保存从节点的复制偏移量
- 从节点自身接收到数据之后，也会累加自己的偏移量，统计信息在 info replication 中
- 对比主从节点的复制偏移量，就可以看出主从节点数据是否一致


2、主节点复制积压缓冲区
- 复制积压缓冲区是一个保存在主节点的一个固定长度的先进先出的队列。默认大小 1M
- 这个队列在 slave 连接时创建，主节点响应写命令时，不但会把命令发送给从节点，也会写入复制缓冲区
- 用于部分复制和复制命令丢失的数据补救。通过 info replication 可以看到相关信息


3、主节点运行 ID
- 每个 redis 启动的时候，都会生成一个 40 位的运行 ID
- 是用来识别 Redis 节点，如果单纯基于ip+port，RDB/AOF文件被修改，那数据同步会发生问题，这个id当节点重启会变化，那么从节点的复制将会是全量复制，不是依照上一次的偏移量继续同步
- 如果在暂停和启动的过程中并没有造成RDB/AOF的修改，那么也可以使用debug reload命令，使从节点不因主节点重启而全量复制，提高了效率，一般用于故障恢复，而不用于普通产线运维

### 三、全量复制
- 通过上面的介绍，我们知道临时添加一个节点，通过slaveof 和 psync如何进行数据的同步
- 接下去通过细节看一下全量复制的流程
- 全量复制可以发生在从节点第一次连接主节点进行数据同步的时候，或者使用psync的命令，手动触发节点数据的同步
- 我们通过psync的命令介绍具体步骤
```text
    slave                                                   master
    
1: psync id -1                  -------1------>

                                <------2--------     2:  FULLRESYNC runid offset
                                
3: 记录主节点id和offset                                4： 主节点出发bgsave,保存RDB到本地（耗时）

                                <------RDB------     5: 发送RDB给从节点
                                
6:从节点接收RDB文件，放入内存      <------RDB------     

                                <----Buffer-----     7： 主节点将从节点同步期间的操作放在“复制客户端缓冲区”中，等到从节点同步完毕再发送给从节点                         
8：从节点清空数据，加载RDB（耗时）                           (Flush old data)
    （Load RDB）
    
9:如果开启AOF-----yes----bgwriteaof 调整AOF文档的结构 重建AOF文件，消除冗余
         |
         |-------no-----结束                     

```
- 以上需要关注一些参数
```text
slave-server-stale-data  关闭该项，可以是从节点在复制节点不对外提供服务，导致数据不一致

repl-timeout redis的超时机制，默认60s,可以调整，导致因为超时而全量复制失败

```

### 四、部分复制
- 一旦连接上主节点之后，从节点就会持续地进行部分复制，或者当从节点数据同步失败，需要重新请求部分数据地时候，也需要发起部分复制
- 部分复制流程
```text
     slave                                                             master
     
1: 连接失败（网络抖动，部分异常）超过了 repl-timeout 时间       ×××××   2：主节点将请求地数据写入“复制挤压缓冲区”（默认1M）

3：重连主节点，会根据runid和offset发起部分复制psync id offset  ------>  4:主节点校验后，从数据缓冲区检验是否存在，如果存在就响应continue

                                                          <------   5:主节点发送缓冲区数据给从节点
```

### 五、心跳机制
- 了解所有分布式，应该对主从心跳并不陌生，基于底层NIO，发送一个字节，或者指定标识地数据内容，来保持两个节点直接的连接
- 通过 client list 命令查看复制相关客户端信息，主节点的连接状态为 flags = M，从节点的连接状态是 flags = S
- 主节点默认每隔 10 秒对从节点发送 ping 命令，配置repl-ping-slave-period 控制发送频率
- 从节点主线程每隔一秒发送 replconf ack{offset} 命令，向主节点上报数据复制偏移量
- 主节点收到 replconf 信息后，判断从节点超时时间，如果超过 repl-timeout 60 秒，则判断节点下线
```text
    slave ------------ping ------------>    master
          |                           |
          |                           |
          <-----replconf ack{offset}---
```
### 六、异步复制
- 异步复制就是主节点把写命令发送给从节点，并不等待从节点的响应，直接响应新的客户端请求，数据复制的过程是异步的



 