> 线程相关的基本方法有wait，notify，notifyAll，sleep，join，yield

```text
                    New 
                     |
                    \|/
 Timed Waiting                 
   Waiting  <---   Ready <--------|
                     |            |
                    \|/           |
                    
                   Running ---->Blocked
                     |
                    \|/
                Terminated
                     
```

### wait 线程等待
- 调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回
- 会释放对象的锁
- 一般用在同步方法或同步代码块中

### sleep 线程睡眠
- sleep不会释放当前占有的锁
- sleep(long)会导致线程进入TIMED-WATING状态

### yield 线程让步
- 当前线程让出CPU执行时间片，与其他线程一起重新竞争CPU时间片

### interrupt 线程中断
- 中断一个线程，其本意是给这个线程一个通知信号，会影响这个线程内部的一个中断标识位
- 这个线程本身并不会因此而改变状态(如阻塞，终止等)


### join等待其他线程终止
当前线程调用一个join，当前线程转为阻塞状态，会等到另一个县城结束，当前线程由阻塞状态变为就绪状态，等待CPU

### 为什么要用join方法？
- 主线程生成并启动子线程，主线程需要子线程结束才继续运行，就需要用join

### 线程唤醒 notify
Object notify方法，唤醒在此对象监视器上等待的单个线程，，如果所有线程都在此对象上等待，
则会选择唤醒其中一个线程，选择是任意的，并在对实现做出决定时发生，线程通过调用其中一个 wait() 方法，
在对象的监视器上等待，直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程，
被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争。类似的方法还有 notifyAll() ，唤醒再次监视器上等待的所有线程

1. sleep()：强迫一个线程睡眠Ｎ毫秒。 
2. isAlive()： 判断一个线程是否存活。 
3. join()： 等待线程终止。 
4. activeCount()： 程序中活跃的线程数。 
5. enumerate()： 枚举程序中的线程。 
6. currentThread()： 得到当前线程。 
7. isDaemon()： 一个线程是否为守护线程。 
8. setDaemon()： 设置一个线程为守护线程。(用户线程和守护线程的区别在于，是否等待主线程依赖于主线程结束而结束) 
9. setName()： 为线程设置一个名称。 
10. wait()： 强迫一个线程等待
11. notify()： 通知一个线程继续运行。 
12. setPriority()： 设置一个线程的优先级。 
13. getPriority():：获得一个线程的优先级。

### 线程上下文切换
巧妙地利用了时间片轮转的方式, CPU给每个任务都服务一定的时间，然后把当前任务的状态保存下来，
在加载下一任务的状态后，继续服务下一任务，任务的状态保存及再加载, 这段过程就叫做上下文切换

#### 什么是上下文？
是指某一时间点 CPU 寄存器和程序计数器的内容

#### 什么是寄存器
是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）。寄存器通过对常用值（通常是运算的中间值）的快速访问来提高计算机程序运行的速度

#### 什么是程序计数器
是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统

#### 什么是PCB-“切换桢”
上下文切换可以认为是内核（操作系统的核心）在 CPU 上对于进程（包括线程）进行切换，上下文切换过程中的信息是保存在进程控制块（PCB, process control block）中的。PCB还经常被称作“切换桢”（switchframe）。信息会一直保存到CPU的内存中，直到他们被再次使用

#### 上下文切换流程
1. 挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处。 
2. 在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复。 
3. 跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程在程序中。

#### 上下文切换的原因
1. 当前执行任务的时间片用完之后，系统CPU正常调度下一个任务； 
2. 当前执行任务碰到IO阻塞，调度器将此任务挂起，继续下一任务； 
3. 多个任务抢占锁资源，当前任务没有抢到锁资源，被调度器挂起，继续下一任务；
4. 用户代码挂起当前任务，让出CPU时间； 
5. 硬件中断

### 线程池原理？
线程池做的工作主要是控制运行的线程的数量，处理过程中将任务放入队列，然后在线程创建后启动这些任务，如果线程数量超过了最大数量超出数量的线程排队等候，等其它线程执行完毕，再从队列中取出任务来执行。
他的主要特点为：线程复用；控制最大并发数；管理线程

#### 线程复用
每一个 Thread 的类都有一个 start 方法。 当调用start启动线程时Java虚拟机会调用该类的 run 方法。 
那么该类的 run() 方法中就是调用了 Runnable 对象的 run() 方法。 我们可以继承重写 Thread 类，
在其 start 方法中添加不断循环调用传递过来的 Runnable 对象。 这就是线程池的实现原理。
循环方法中不断获取 Runnable 是用 Queue 实现的，在获取下一个 Runnable 之前可以是阻塞的。

#### 线程池的组成
1. 线程池管理器：用于创建并管理线程池 
2. 工作线程：线程池中的线程 
3. 任务接口：每个任务必须实现的接口，用于工作线程调度其运行 
4. 任务队列：用于存放待处理的任务，提供一种缓冲机制
```text
1. corePoolSize：指定了线程池中的线程数量。 
2. maximumPoolSize：指定了线程池中的最大线程数量。 
3. keepAliveTime：当前线程池数量超过corePoolSize时，多余的空闲线程的存活时间，即多次时间内会被销毁。 
4. unit：keepAliveTime的单位。 
5. workQueue：任务队列，被提交但尚未被执行的任务。 
6. threadFactory：线程工厂，用于创建线程，一般用默认的即可。 
7. handler：拒绝策略，当任务太多来不及处理，如何拒绝任务。
```
#### 拒绝策略
线程池中的线程已经用完了，无法继续为新任务服务，
同时，等待队列也已经排满了，再也塞不下新任务了。
这时候我们就需要拒绝策略机制合理的处理这个问题。 
JDK内置的拒绝策略如下： 
1. AbortPolicy ： 直接抛出异常，阻止系统正常运行。 
2. CallerRunsPolicy ： 只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。显然这样做不会真的丢弃任务，但是，任务提交线程的性能极有可能会急剧下降。 
3. DiscardOldestPolicy ： 丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。 
4. DiscardPolicy ： 该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。 
以上内置拒

#### Java线程池工作过程
1. 线程池刚创建时，里面没有一个线程。任务队列是作为参数传进来的。不过，就算队列里面有任务，线程池也不会马上执行它们。 
2. 当调用 execute() 方法添加一个任务时，线程池会做如下判断：
a) 如果正在运行的线程数量小于 corePoolSize，那么马上创建线程运行这个任务； 
b) 如果正在运行的线程数量大于或等于 corePoolSize，那么将这个任务放入队列； 
c) 如果这时候队列满了，而且正在运行的线程数量小于 maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务； 
d) 如果队列满了，而且正在运行的线程数量大于或等于 maximumPoolSize，那么线程池会抛出异常RejectExecutionException。 
3. 当一个线程完成任务时，它会从队列中取下一个任务来执行。 
4. 当一个线程无事可做，超过一定的时间（keepAliveTime）时，线程池会判断，如果当前运行的线程数大于 corePoolSize，那么这个线程就被停掉。所以线程池的所有任务完成后，它最终会收缩到 corePoolSize 的大小。


### java阻塞队列
- 队列为空，消费者端阻塞
- 队列满，生产者端阻塞
- 添加元素 add offer put的区别
- 获取元素 poll take draintTo
- 类别：
```text
1. ArrayBlockingQueue ：由数组结构组成的有界阻塞队列。 
用数组实现的有界阻塞队列。此队列按照先进先出（FIFO）的原则对元素进行排序。默认情况下不保证访问者公平的访问队列
保证公平就不能保证吞吐量

2. LinkedBlockingQueue ：由链表结构组成的有界阻塞队列。
LinkedBlockingQueue之所以能够高效的处理并发数据，还因为其对于生产者端和消费者端分别采用了独立的锁来控制数据同步，这也意味着在高并发的情况下生产者和消费者可以并行地操作队列中的数据，以此来提高整个队列的并发性能

3. PriorityBlockingQueue ：支持优先级排序的无界阻塞队列。
是一个支持优先级的无界队列。默认情况下元素采取自然顺序升序排列。可以自定义实现compareTo()方法来指定元素进行排序规则，或者初始化PriorityBlockingQueue时，指定构造参数Comparator来对元素进行排序。
需要注意的是不能保证同优先级元素的顺序

 
4. DelayQueue：使用优先级队列实现的无界阻塞队列。 
是一个支持延时获取元素的无界阻塞队列。队列使用PriorityQueue来实现。队列中的元素必须实现Delayed接口，在创建元素时可以指定多久才能从队列中获取当前元素
1. 缓存系统的设计：可以用DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue，一旦能从DelayQueue中获取元素时，表示缓存有效期到了。
2. 定时任务调度：使用DelayQueue保存当天将会执行的任务和执行时间，一旦从DelayQueue中获取到任务就开始执行，从比如TimerQueue就是使用DelayQueue实现的。

5. SynchronousQueue：不存储元素的阻塞队列。 
是一个不存储元素的阻塞队列。每一个put操作必须等待一个take操作，否则不能继续添加元素
队列本身并不存储任何元素，非常适合于传递性场景,比如在一个线程中使用的数据，传递给另外一个线程使用

6. LinkedTransferQueue：由链表结构组成的无界阻塞队列。
是一个由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了tryTransfer和transfer方法
 
7. LinkedBlockingDeque：由链表结构组成的双向阻塞队列
是一个由链表结构组成的双向阻塞队列。所谓双向队列指的你可以从队列的两端插入和移出元素
相比其他的阻塞队列，LinkedBlockingDeque多了addFirst，addLast，offerFirst，offerLast，peekFirst，peekLast等方法，以First单词结尾的方法，表示插入，获取（peek）或移除双端队列的第一个元素
```

