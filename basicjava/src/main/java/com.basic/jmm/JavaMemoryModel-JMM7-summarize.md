- 对于以上Java内存模型应该也有了一定了解，非常重要的重排序功能，关于一些内存可见和特殊数据类型，讲述了它们的内存指令规则，也对我们的理解有了进一步加深
- 接下来做一些知识的总述

### 1、处理器内存模型
- 前面有讲到顺序一致性内存模型，是将指令顺序按照编码顺序顺序执行，那么这样并发度和性能会低，处理器就是为了增强并发度，因而顺序一致性模型只能是内存模型的一个基本参照
- 根据读写组合，常见的处理器内存模型可以分为：
    - 放松程序中写-读操作的顺序，由此产生了total store ordering内存模型（简称为TSO）
    - 在前面1的基础上，继续放松程序中写-写操作的顺序，由此产生了partial store order 内存模型（简称为PSO）
    - 在前面1和2的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了relaxed memory order内存模型（简称为RMO）和PowerPC内存模型
    - 这里处理器对读/写操作的放松，是以两个操作之间不存在数据依赖性为前提的

- 所有处理器内存模型都允许写-读重排序，它们都使用了写缓存区，写缓存区可能导致写-读操作重排序
- 可以看到这些处理器内存模型都允许更早读到当前处理器的写，原因同样是因为写缓存区：由于写缓存区仅对当前处理器可见，这个特性导致当前处理器可以比其他处理器先看到临时保存在自己的写缓存区中的写
- 一般的处理器内存模型 ，由于追求处理器的性能，往往不会设计过于约束的内存模型
- JMM的内存模型为了适应不同处理器对内存模型的设计，保证内存的可见性，利用再不同指令之间设置不同的内存屏障，给程序员展示了一个一致的内存模型

### 2、JMM，处理器内存模型与顺序一致性内存模型之间的关系
- JMM是一个语言级的内存模型，处理器内存模型是硬件级的内存模型，顺序一致性内存模型是一个理论参考模型
- 易编程性：PowerPC < ia64 < sparc-PSO < x86 < sparc-TSO < C++11 MM < JMM < CLR2.0 MM < Sequential Consistency
- 执行性能: PowerPC > ia64 > sparc-PSO > x86 > sparc-TSO > C++11 MM > JMM > CLR2.0 MM > Sequential Consistency
- 常见的 4 种处理器内存模型比常用的 3 中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱
- 越是追求执行性能的语言，内存模型设计的会越弱

### 3、JMM 的设计
- 对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序
- 对于不会改变程序执行结果的重排序，JMM 对编译器和处理器不作要求（JMM 允许这种重排序）


- JMM 向程序员提供的 happens- before 规则能满足程序员的需求。JMM 的 happens- before 规则不但简单易懂，而且也向程序员提供了足够强的内存可见性保证
- JMM 对编译器和处理器的束缚已经尽可能的少。从上面的分析我们可以看出，JMM 其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。比如，如果编译器经过细致的分析后，认定一个锁只会被单个线程访问，那么这个锁可以被消除。再比如，如果编译器经过细致的分析后，认定一个 volatile 变量仅仅只会被单个线程访问，那么编译器可以把这个 volatile 变量当作一个普通变量来对待。这些优化既不会改变程序的执行结果，又能提高程序的执行效率

### 4、JMM 的内存可见性保证
- Java 程序的内存可见性保证按程序类型分为：
    - 单线程程序。单线程程序不会出现内存可见性问题。编译器，runtime 和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同
    - 正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性，JMM 通过限制编译器和处理器的重排序来为程序员提供内存可见性保证
    - 未同步 / 未正确同步的多线程程序。JMM 为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，null，false）
    
### 5、JSR-133 对旧内存模型的修补
- JSR-133 对 JDK5 之前的旧内存模型的修补主要有两个
    - 增强 volatile 的内存语义。旧内存模型允许 volatile 变量与普通变量重排序。JSR-133 严格限制 volatile 变量与普通变量的重排序，使 volatile 的写 - 读和锁的释放 - 获取具有相同的内存语义
    - 增强 final 的内存语义。在旧内存模型中，多次读取同一个 final 变量的值可能会不相同。为此，JSR-133 为 final 增加了两个重排序规则。现在，final 具有了初始化安全性
    
