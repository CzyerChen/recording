#### 结构性：
- 适配器：新旧接口适配  Arrays.asList
- 桥接模式：面向接口，就是使用了桥接模式
- 组合模式：返回一个自己的对象 Builder Map.putAll
- 装饰者模式:子类化的一种实现BufferedInputStream(InputStream)
- 门面模式：Class使用的SLFJ日志就是门面日志，比如使用Dubbo，向外提供的服务就尽量采用门面模式，服务在调用各种service做聚合
- 享元模式：使用缓存的时候基本会涉及享元模式，Integer.valueOf()
- 代理模式：动态代理啦，Proxy

#### 创建模式：
- 抽象工厂：Calendar.getInstance(),Connection.createStatement(),Arrays.asList
- 建造者: StringBuilder.append StringBuffer,append PrepareStatement
- 工厂: Class.forName Proxy.newProxyInstance Class.newInstance
- 原型:Object.clone 实现对象拷贝
- 单例：Runtime.getRuntime()

#### 行为模式：
- 责任链：涉及到Filter拦截器的
- 命令：Runnable将命令封装在对象中
- 解释器：Pattern 正则匹配
- 迭代器：Interator，枚举Enumeration
- 中介者：Executor.execute / ExecutorService.submit / Method.invoke通过中间商来解耦
- 备忘录：Date(内部是一个long)/Serializable
- 观察者：接收广播消息，EventListener
- 状态：Interator 涉及到状态的管理的都可以算是用到了这个模式
- 策略：Comparator.compare() / Filter.doFilter  Collection.sort
- 模板方法： InputStream.read AQS
- 访问者：

//==================================================================================//
### 一、结构性模式：
1、适配器模式：业务代码中经常有新旧接口适配需求，可以采用该模式
 

2、桥接模式：只要你用到面向接口编程，其实都是在用桥接模式
- 将抽象和抽象的具体实现进行解耦，这样可以使得抽象和抽象的具体实现可以独立进行变化。

3、组合模式
- 让客户端看起来在处理单个对象和对象的组合是平等的，换句话说，某个类型的方法同时也接受自身类型作为参数。组合模式常用于递归操作的优化上，比如Builder的模式，Map.putAll等
 

4、装饰者模式
- 动态的给一个对象附加额外的功能，因此它也是子类化的一种替代方法
- 这个模式使用就太广了，我们常用的AOP，既有动态代理，也有装饰者的味道
 

5、门面模式
- 为一组组件，接口，抽象或子系统提供简化的接口。
 - 使用的SLFJ日志就是门面日志，比如我们使用Dubbo，向外提供的服务就尽量采用门面模式，然后服务在调用各种service做聚合

6、享元模式
- 使用缓存来减少对小对象的访问时间
- 只要用到缓存，基本就是在使用享元模式的思想

7、代理模式
- 代理模式用于向较简单的对象代替创建复杂或耗时的对象。
- Java.lang.reflect.Proxy
- RMI远程调用
- 动态代理就是代理模式


### 二、创建模式
1、抽象工厂模式
- 该模式可以与策略模式结合使用

2、建造者模式
- 用于通过定义一个类来简化复杂对象的创建，该类的目的是构建另一个类的实例。构建器模式还允许实现Fluent接口
- 比如订单系统大部分项目都有，订单对象就是一个复杂对象，我们就可以采用建造者模式来做

3、工厂方法
 

4、原型模式
- 使得类的实例能够生成自身的拷贝。如果创建一个对象的实例非常复杂且耗时时，就可以使用这种模式，而不重新创建一个新的实例，你可以拷贝一个对象并直接修改它。
 

5、单例模式
- 在平时开发中，单例是我们用得最多的了，因为Spring的bean，默认就是单例级别的

### 三、行为模式
1、责任链：通过把请求从一个对象传递到链条中下一个对象的方式来解除对象之间的耦合，直到请求被处理完毕
- 凡是带有Filter关键词的，基本都在用这个设计模式。在业务代码使用的场景实在是太多了，用到拦截器的地方基本都在用这个设计模式。

2、命令模式：将命令包装在对象中，以便可以将其存储，传递到方法中，并像任何其他对象一样返回。
 
3、解释器模式

4、迭代器模式：提供一个统一的方式来访问集合中的对象。
 
5、中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。
- 用MQ，其实就是在用中介者模式

6、备忘录模式
- 生成对象状态的一个快照，以便对象可以恢复原始状态而不用暴露自身的内容。比如Date对象通过自身内部的一个long值来实现备忘录模式。
- 其中一种场景是，你要把数据丢到MQ，但是MQ暂时不可用，那么你把数据暂存到DB，后面再轮询丢到MQ

7、空对象模式：允许您抽象空对象的处理。
 

8、观察者模式：用于为组件提供一种灵活地向感兴趣的接收者广播消息的方式。
- 业务代码一般是基于Zookeeper来做观察者的。基本上用到ZK的地方，都是在用观察者模式，比如分布式锁，比如服务发现等

9、状态模式
- 比如我们常见的订单状态或者各种XX状态，都可以用得上

10、策略模式	
- 使用这个模式来将一组算法封装成一系列对象。通过调用这些对象可以灵活的改变程序的功能
 

11、模板方法模式
- 让子类可以重写方法的一部分，而不是整个重写，你可以控制子类需要重写那些操作。
- 可以做一个抽象类，子类来实现差异化


12、访问者模式
- 提供一个方便的可维护的方式来操作一组对象。它使得你在不改变操作的对象前提下，可以修改或者扩展对象的行为       
