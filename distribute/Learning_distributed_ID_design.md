- 这个记录的起源是来自于大佬们的推文，也是我应该会遇到的问题
- 涉及到分布式的业务，就必须会结合业务发生全局唯一ID的思考
- 存储系统是分布式的，缓存系统是分布式的，关系型数据库走向分库分表了，怎么样维系一个唯一的连续的ID是一个难题
- 通过阅读美团大佬们整理的关于LEAF全局唯一ID设计的思想，做出一下学习总结

### 一、背景
- 首先，全局唯一ID是有很重大的意义的，不论是怎样的分布式系统，在一个唯一标识上，总希望尽善尽美地标识每一条数据
- 我当前学习和了解这个知识的初衷是源于关系数据库分库分表的需求，因为数据库的拆分，导致数据节点和对应ID关系成了研究点，可以先了解[分库分表的背景](https://github.com/CzyerChen/recording/blob/master/dbhelper/src/main/java/com.dbhelper/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8.md)

### 二、解决方案
#### 1.方案一：UUID
- UUID是业务场景中使用得长广泛的一种形式
- 如何生成
```text
UUID是唯一识别码
它是一台机器上生成的数字，保证在同一时空中所有机器都是唯一的
```
- 组成部分（8-4-4-16）
    - 当前日期时间
    - 时钟序列
    - 全局唯一的IEEE机器识别号，如果有网卡就会从MAC地址获取

- 物理时钟：从客观的角度来说，32位的UUID是基本不可能重复的，但是过分强的依赖机器时钟，因而也不能避免因时钟回拨而产生的重复问题
- 安全：由于机器识别号会暴露网卡MAC地址等数据，相对来说，安全还是有所缺失
- 存储：由于位数为32位，在计算机存储较长，也不适合数据库底层存储
- UUID是本地生成，性能非常高，没有网络传输，介于安全和完全非重的这些要求没有那么敏感的UUID是一个比较好的选择

#### 2.方案二：类snowflakes
- 以划分命名空间产生ID的算法
- 把64位分蘖划分成多段，表示机器、时间等，1-41-10-12，1位符号位，41位时间位，10为机器ID，12位自增序列
- 其中41位表示时间，(1L << 41)/(1000L * 3600 * 24 * 365) = 69年时间
- 10位机器码分别表示1024台机器，更细可以划分为5位IDC，可以表示2^5=32个IDC，5位工作机器
- 

#### 3.方案三：美团Leaf

1.UUID 生成36位的唯一ID，能够和MAC地址绑定生成，因而被认为具有一定风险，可能被侵入MAC地址
2.类Snowflakes  64位：1+41+10+12，空位+时间戳位+workID+递增序列，缺点是过分依赖物理时钟，服务器时钟不同步会造成ID重复，对于ID敏感的业务是致命的
3.MangoDB objectId 使用时间+机器码+pid+inc 共24位
4.数据库自带的自增Id,如果是不同的库，就采用相同的步长，不同起始值来做到不同的数据库，能够拿到不一样的递增ID，这个过分依赖数据库，数据库压力过大
5.Leaf的分布式全局ID的策略：有业务和最大ID对应的表
5.1 Leaf-segment 是对数据库区域ID的优化
5.2 Leaf 双buff 双BUff是对上面方法的优化，采用前一批缓存仅剩百分之10的情况，预加载下一批的ID数据，给数据库宕机提供一个保证
5.3 Leaf的高可用 主要对DB做负载的代理，多主多从